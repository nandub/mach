#!@PYTHON@
#
# mach - make a chroot
#
# script to set up a chroot using packages and optionally perform builds in it

import sys, os, stat
import getopt, string, commands, urllib, shutil, time, fcntl, re
import rpm # FIXME: find out what rpm version we need !
import random # spinner theming madness
import tempfile # for tempdir for spec extraction
import glob # for globbing paths
import grp # for finding out the mach gid

# make sure True and False constants exist

if not hasattr (__builtins__, 'True'):
    __builtins__.True = (1 == 1)
    __builtins__.False = (1 != 1)

# usage and help
usage = 'usage: mach [mach-options] command [command-options-and-arguments]'
help = '''Make a chroot and do stuff in it.

Mach options:
  -r, --root=ROOT		specify a root to work in
  -d, --debug			turn on debugging
  -f, --force			override root lock
  -k, --keep			do not revert buildroot to initial package list
  -s, --sign			sign packages after build
  -c, --collect			collect packages and relevant files to .
  --release=(tag)		add given tag to release tag

Commands:
  apt-get			run host's apt-get on target root
  apt-cache                     run host's apt-cache on target root
  build				build from (set of) .spec file(s)
                                (passes options given to rpmbuild)
  chroot			chroot into root
  clean				totally cleans the root
  check				check if a root can be set up
  rebuild			rebuild a (set of) .src.rpm(s)
                                (passes options given to rpmbuild)
  setup				sets up the root for a particular purpose
        prep                         preparation before package install
        base                         base set of rpms to make rpm work
        consistency                  internally consistent install
        build                        everything to build rpms
  status			show status of mach roots
  unlock			override root lock
'''

# read default configuration
config = {
  'force': 0,
  'check': 0,
  'sign': 0,
  'collect': 0,
  'release': 0,
  'defaultroot': 'redhat-9-i386', # FIXME: based on configure's distro check

  'chroot': '@SBINDIR@/mach-helper chroot',
  'mount': '@SBINDIR@/mach-helper mount',
  'rpm': '@SBINDIR@/mach-helper rpm',
  'umount': '@SBINDIR@/mach-helper umount',
  'apt-get': '@SBINDIR@/mach-helper apt-get',
  'apt-cache': '/usr/bin/apt-cache',

}
DEBUG = 0

# read system-wide configuration
file = '@SYSCONFDIR@/mach/conf'
execfile (file)

# read apt information
aptsources = {}
#file = '@SYSCONFDIR@/mach/apt'
#execfile (file)

# read dist information
packages = {}
sourceslist = {}
file = '@SYSCONFDIR@/mach/dist'
execfile (file)

# read user configuration
file = os.path.join (os.environ['HOME'], '.machrc')
try:
    execfile (file)
except IOError:
    pass

# list of allowed commands
allowed_commands = ('apt-get', 'apt-cache', 'build',
                    'check', 'chroot', 'clean', 'rebuild', 'rpm',
                    'setup', 'status', 'unlock')

# rpm -q format, users may have customized %_query_all_fmt in ~/.rpmmacros...
qfmt = '"%{name}-%{version}-%{release}\n"'

### objects
class Spec:
    def __init__ (self, path):
        self.path = path
        self.content = []
        self.vars = {}
        self.content = open (self.path).readlines ()
        for which in ['name', 'version', 'release']:
            self.vars[which] = self.tag (which)

    def tag (self, which):
        "Get the given (unique) tag from the spec file as a string"
        if self.vars.has_key (which):
            return self.vars[which]

        matchstr = re.compile ("^" + which + r"\d*:\s*(.*)", re.I)
        for line in self.content:
            match = matchstr.search (line)
            if match:
                value = match.expand ("\\1")
                self.vars[which] = value
                return value
        return None

    def tags (self, which):
        "Get all given tags from the spec file as a list"
        result = []
        matchstr = re.compile ("^" + which + r"\d*:\s*(.*)", re.I)
        for line in self.content:
            match = matchstr.search (line)
            if match:
                value = match.expand ("\\1")
                result.append (value)
        return result

    # this is done quick and dirty, could be optimized more
    def expand (self, expression):
        "expand a line from a spec file using vars from the spec file"
        for variable in self.vars.keys ():
            expression = string.replace (expression, "%{" + variable + "}",
                                         self.vars[variable])
        #print "DEBUG: expanded to %s" % expression
        return expression

    def nvr (self):
        "return name, version, release triplet"
        return (self.vars['name'], self.vars['version'], self.vars['release'])
 

    # make this private
    def sourcespatches (self, which):
        result = {}
        matchstr = re.compile ("^(" + which + r"\d*):\s*(.*)")
        for line in self.content:
            match = matchstr.search (line)
            if match:
                tag = match.expand ("\\1")
                value = match.expand ("\\2")
                result[tag] = self.expand (value)
        return result
 
    def sources (self):
           # parse the spec file for all Source: files
           return self.sourcespatches ("Source")

    def patches (self):
           # parse the spec file for all Source: files
           return self.sourcespatches ("Patch")
 
### abstract object wrapping a src rpm
class SRPM:
    class Error(Exception): pass
    def __init__ (self, path):
        self.path = path
        self.header = self._header ()
        self.specname = self._specname ()
        # ignore signatures

    def _header (self):
        "get the rpm header from the src.rpm"
        debug ("Getting RPM header from %s" % self.path)
        ts = rpm.TransactionSet ("", (rpm._RPMVSF_NOSIGNATURES))
        fd = os.open (self.path, os.O_RDONLY)
        try:
            header = ts.hdrFromFdno (fd)
        except:
            print "a whoopsie occurred."
        if not header:
            raise self.Error, "%s doesn't look like a .src.rpm" % self.path
        return header

    def _specname (self):
        "return the name of the specfile inside this src.rpm"
        name = commands.getoutput ('rpm -qlp %s 2> /dev/null | grep \.spec$' % self.path)
        debug ("SRPM.specname: %s" % name)
        return name
    
    def BuildRequires (self):
        "return a list of BuildRequires for this src.rpm"
        buildreqs = self.header[rpm.RPMTAG_REQUIRENAME]
        # remove non-packagey things from buildreqs
        # currently removes everything containing ( or /
        if buildreqs:
            return filter(lambda x: not re.search("[(/]", x), buildreqs)
        else:
            return None

    def results (self):
        "returns a list of packages that can be built from this src.rpm"
        # FIXME: this extracts the spec file out of the src.rpm and
        # puts it in a temp dir; is this the cleanest option ?
        debug ("Getting possible result packages from src.rpm %s" % self.path)
        path = self.path
        specname = self.specname
        tmpdir = tempfile.mktemp ()
        ensure_dir (tmpdir)
        cmd = 'cd %s && rpm2cpio %s \
               | cpio -id --no-absolute-filenames %s \
               > /dev/null 2>&1' % (tmpdir, path, specname)
        os.system (cmd)
        spectmp = os.path.join (tmpdir, self.specname)
        if not os.path.exists (spectmp):
            raise self.Error, "didn't find spec file in %s" % self.path
        cmd = "rpm -q --specfile %s" % spectmp
        output = commands.getoutput (cmd)
        debug ("output of rpm -q --specfile: \n%s" % output)
        spec = Spec (spectmp)
        (n, v, r) = spec.nvr ()
        # strip v and r off of output
        result = []
        for line in output.split ("\n"):
            result.append (line.replace ('-%s-%s' % (v, r), ''))
        debug ("results of srpm: %s" % result)
        return result
 
### abstract object acting on the root
# FIXME: we can subclass this based on actual method to install stuff
class Root:
    # exceptions that can be raised
    class Locked(Exception): pass
    class Error(Exception): pass
    class ReturnValue(Exception): pass
    # read in configuration from disk when creating a root
    def __init__ (self, config):
        self.config = config
        self.root = self.config['root']
        self.rootdir = get_config_dir (config, 'root')
        self.resultdir = get_config_dir (config, 'result')
        self.statedir = get_config_dir (self.config, 'state')
        self.tmpdir = get_config_dir (self.config, 'tmp')
        self.packagesdir = os.path.join (config['dirs']['packages'],
                                         config['packages']['dir'])

    # small helper functions
    def lock (self):
        "Lock this root for operations"
        ensure_dir (self.statedir)
        debug ("locking root")
        lockpath = os.path.join (self.statedir, 'lock')
        if os.path.exists (lockpath):
            if not self.config['force']:
                raise self.Locked
            else:
                print 'warning: overriding lock on root %s' % self.root
        try:
            lockfile = open (lockpath, 'w')
        except:
            raise self.Error, 'error: can''t create lock file for %s !\n' % self.root
        lockfile.close ()
     
    def unlock (self, args = []):
        "Unlock this root for operations"
        debug ("unlocking root")
        lockpath = os.path.join (self.statedir, 'lock')
        if os.path.exists (lockpath):
            os.remove (lockpath)
        else:
            raise self.Error, 'error: %s not locked !' % self.root
 
    def get_state (self, which):
        "Returns None if the state file doesn't exist, and contents if it does"
        path = os.path.join (self.statedir, which)
        if os.path.exists (path):
            return open (path, 'r').readlines ()
        else:
            return None

    # default here assures that state files are never empty
    def set_state (self, which, content = ""):
        "Creates the state file and fill it with given contents."
        #FIXME: if we do want Error, wat about apt.conf ?
        #"raises Error if it already existed."
        if not content: content = which
        path = os.path.join (self.statedir, which)
        #if os.path.exists (path):
        #    raise self.Error, "State file %s exists already" % path
        debug ('outputting state')
        debug (content)
        debug ('outputted state')
        open (path, 'w').write (content)

    def stdout (self, message):
        #FIXME: check verbosity here
        "outputs this message to stdout"
        sys.stdout.write (message)

    def mount (self):
        "mount apt-archives and proc into chroot"
        # first umount for completeness; you never know
        self.umount ()
        debug ("mounting proc and apt-archives")
        file = open (os.path.join (self.statedir, 'mount'), "w+")
        #command = '%s -t proc proc %s/proc' % (self.config['mount'], self.rootdir)
        #debug (command)
        #os.system (command)
        #file.write ('%s/proc\n' % self.rootdir)
        ensure_dir (os.path.join (self.statedir, 'apt@SYSCONFDIR@/apt'))
        ensure_dir (os.path.join (self.statedir, 'apt/var/cache/apt/archives'))
        ensure_dir (os.path.join (self.statedir, 'apt/var/state/apt/lists/partial'))
        command = ('cp -a @SYSCONFDIR@/apt/rpmpriorities %s/apt@SYSCONFDIR@/apt/rpmpriorities' % self.statedir)
        debug (command)
        os.system (command)
        command = ('%s -o bind %s %s/apt/var/cache/apt/archives' % (
                   self.config['mount'], self.config['dirs']['archives'],
                   self.statedir))
        debug (command)
        os.system (command)
        file.write ('%s/apt/var/cache/apt/archives\n' % self.statedir)
        file.close ()
        
    # umount all mounted paths
    def umount (self):
        if not self.get_state: return
        mountfile = os.path.join (self.statedir, 'mount')
        if not os.path.exists (mountfile): return
        debug ('cat %s | xargs %s' % (mountfile, self.config['umount']))
        os.system ('cat %s | xargs %s' % (mountfile, self.config['umount']))
        os.remove (mountfile)

    # recreate a given file listed in config['files']
    def config_recreate (self, filename):
        debug ("Recreating %s from config" % filename)
        if self.config['files'].has_key (filename):
            ensure_dir (os.path.dirname (self.rootdir + filename))
            tmpname = os.path.join ('tmp', os.path.basename (filename))
            file = open (os.path.join (self.rootdir, tmpname), 'w')
            file.write (config['files'][filename])
            file.close ()
            os.rename(os.path.join (self.rootdir, tmpname), self.rootdir + filename)

    # seek through the argument list for specfiles
    def splitargspecs (self, argstring):
        specs = []
        other = []
        match = re.compile('\.spec$', re.I)
        for arg in argstring.split ():
            if match.search(arg):
                spec.append (arg)
            else:
                other.append (arg)
        return (other, specs)

    # seek through the argument list for srpms
    def splitargsrpms (self, argstring):
        srpms = []
        other = []
        match = re.compile('\.src\.rpm$', re.I)
        for arg in argstring.split ():
            if match.search(arg):
                srpms.append (arg)
            else:
                other.append (arg)
        return (other, srpms)

    # run apt from outside the root on the root
    # FIXME: virtualize this
    # FIXME: provide a way to not catch output so it can be run on a chroot
    # line interactively
    def aptget (self, arg, progress = False):
        "run apt-get (arg) from outside the root on the root"
        self.mount ()
        conf = os.path.join (self.statedir, 'apt.conf')
        command = "%s -c %s %s" % (self.config['apt-get'], conf, arg)
        (status, output) = do_with_output (command, progress)
        self.umount ()
        if status != 0:
            raise self.Error, "Could not apt-get %s" % arg

    def aptcache (self, arg, progress = False):
        "run apt-cache (arg) from outside the root on the root"
        self.mount ()
        conf = os.path.join (self.statedir, 'apt.conf')
        command = "%s -c %s %s" % (self.config['apt-cache'], conf, arg)
        (status, output) = do_with_output (command, progress)
        self.umount ()
        if status != 0:
            raise self.Error, "Could not apt-cache %s" % arg
        print output

    def rpm (self, arg, progress = False):
        "run rpm (arg) from outside the root on the root, returns output"
        command = "%s --root %s %s" % (self.config['rpm'], self.rootdir, arg)
        (status, output) = do_with_output (command, progress)
        if status != 0:
            raise self.Error, "Could not rpm %s" % arg
        return output

    # main command executer:
    # - executes on host
    # - direct execution with std's connected or output captured (FIXME)
    # - show or don't show progress meter
    # FIXME: user ?
    def do (self, command, progress = True, user = ""):
        "execute given command"
        debug ("Executing %s" % command)
        if progress:
            return do_progress (command)
        else:
            (status, output) = commands.getstatusoutput (command)
    
        if os.WIFEXITED (status):
            retval = os.WEXITSTATUS (status)
        if (retval != 0):
            raise self.ReturnValue, retval
        return output
    
    def do_chroot (self, command, progress = False, user = ""):
        "execute given command in root"
        # HACK: FIXME: 
        # if the cmd already contains -c ' as a sequence, then don't wrap
        # it in /bin/bash
        cmd = ""
        if string.find (command, "-c '") > -1:
            cmd = "%s %s %s" % (config['chroot'], self.rootdir, command)
        else:
            cmd = "%s %s su - root -c '%s'" % (config['chroot'],
                                               self.rootdir, command)
        return self.do (cmd, progress)

    def check_bootstrap (self):
        "check if the bootstrap packages are present, download if not"
        # if we already checked once, then we'll assume it's fine unless
        # a check was forced with -c or --check
        # FIXME: this doesn't survive mach clean, is that a problem ?
        if self.get_state ('check') and not self.config['check']:
            return
    
        # check if all packages are present
        print "Checking bootstrap packages ..."
        ensure_dir (self.packagesdir)
        for pkg in self.config['packages']['base']:
            path = os.path.join (self.packagesdir, pkg)
            if not self.config['packages']['download'].has_key (pkg):
                url = self.config['packages']['download'][''] + pkg
            else:
                url = self.config['packages']['download'][pkg] + pkg
            if not os.path.exists (path):
                urlgrab (url, path)
            # verify that it's an rpm
            #ret = os.system ('rpm --checksig --nosignature %s > /dev/null 2>&1' % path)
            if os.system ('rpm --checksig --nosignature %s > /dev/null 2>&1' % path) != 0:
                os.remove (path)
                urlgrab (url, path)
                # retry
                if os.system ('rpm --checksig --nosignature %s > /dev/null 2>&1' % path) != 0:
                    raise self.Error, "failed downloading %s" % url
        self.set_state ('check')

    # check the given package list file
    # remove all packages that aren't in this list file
    def check_package_list (self, listfile):
        "check the given package list file and remove packages not listed"
        debug ("checking package list against snapshot")
        if self.config.has_key ('keep'):
            print "Not removing packages from root."
            return
        root = self.rootdir
        cmd = 'rpm --root %s -qa --qf %s \
               | diff - %s > /dev/null 2>&1' % (root, qfmt, listfile)
        debug ("running " + cmd)
        if os.system (cmd) == 0:
            # no differences
            return True
        cmd = "rpm --root %s -qa --qf %s \
               | grep -v -f %s - \
               | tr '\n' ' '" % (root, qfmt, listfile)
        packages = commands.getoutput (cmd)
        # FIXME: how many ?
        sys.stdout.write ("Removing packages ...")
        if not packages:
           print "Error: packages was empty"
           return True
        self.rpm ("-ev %s" % packages, True)
        return True
    

    # implementation of actual externalized commands
    # actual externalized commands

    def build (self, arg):
        "build from a set of spec files by packaging them up as src.rpm and "
        "passing them to rebuild"
        # check if we can build here yet
        if not self.get_state ('build'):
            self.setup ('build')
        self.lock ()
        
        srpms = [] # resulting set of srpms
        # separate options to rpmbuild from specfiles
        (options, specs) = self.splitargspecs (arg)
        debug ("options to rpmbuild: %s" % options)
        # check if the spec files exist and if we can parse the files necessary
        for specfile in specs:
            if not os.path.exists (specfile):
                raise self.Error, "spec %s does not exist !" % specfile
            self.stdout ("Building .src.rpm from %s\n" % os.path.basename (specfile))
            spec = Spec (specfile)
            (n, v, r) = spec.nvr ()
            # download all referenced files (Sources, Patches)
            downloads = spec.sources ().values () + spec.patches ().values ()
            # which paths will we check for already existing files ?
            # FIXME: add a temp stuff path somewhere instead of using current
            tmppath = "%s/%s-%s-%s" % (self.tmpdir, n, v, r)
            ensure_dir (tmppath)
            # check temporary dir, current dir, and dir where specfile lives
            paths = [tmppath, '.', os.path.dirname (specfile)]
            # check if the files mentioned aren't already on-disk
            files = []
            for download in downloads:
                found = 0
                filename = os.path.basename (download)
                for path in paths:
                    filepath = os.path.join (path, filename)
                    if os.path.exists (filepath):
                        self.stdout ("Using %s\n" % filepath)
                        files.append (filepath)
                        found = 1
                if not found:
                    filepath = os.path.join (tmppath, filename)
                    try:
                        urlgrab (download, filepath)
                    except:
                        raise self.Error, "Could not download %s !" % download
                    files.append (filepath)
                    self.stdout ("Using %s\n" % filepath)
    
            # copy all necessary files to /tmp in root, then chroot to mv them 
            for file in files:
                debug ("Getting file %s into SOURCES" % file)
                shutil.copy2 (file, os.path.join (self.rootdir, 'tmp'))
                self.do_chroot ("cd / && mv %s %s" % (
                                os.path.join ('tmp', os.path.basename (file)),
                                os.path.join ('usr', 'src', 'rpm', 'SOURCES')))
            shutil.copy2 (specfile, os.path.join (self.rootdir, 'tmp'))
            self.do_chroot ("cd / && mv %s %s " % (
                            os.path.join ('tmp', os.path.basename (specfile)),
                            os.path.join ('usr', 'src', 'rpm', 'SPECS')))
            self.stdout ("Creating .src.rpm ...")
            try:
                self.do_chroot ("cd / && rpmbuild -bs --nodeps %s" \
                                % os.path.join ('usr', 'src', 'rpm', 'SPECS', 
                                                os.path.basename (specfile)),
                                  True)
            except:
                raise self.Error, 'error: could not build .src.rpm'
                return False
            (n, v, r) = spec.nvr ()
            srpmname = "%s-%s-%s.src.rpm" % (n, v, r)
            debug ("DEBUG: resulting srpm: %s" % srpmname)
            shutil.copy2 (self.rootdir + '/usr/src/rpm/SRPMS/' + srpmname, tmppath)
            srpms.append (os.path.join (tmppath, srpmname))
    
        # ready to build them all
        print "Rebuilding generated .src.rpm's: \n- %s" % string.join (srpms, "\n- ")
        self.unlock ()
        self.rebuild (string.join (options) + " " + string.join (srpms))
             
    def clean (self, args = ""):
        "clean out the root"
        self.umount ()
        # remove all state info
        debug ("Removing statedir %s" % self.statedir)
        os.system ("rm -rf %s" % self.statedir)
        # FIXME: check if the dir isn't already clean yet
        if not os.path.exists (self.rootdir + '/bin/rm'):
            raise self.Error, "no base installed in %s !" % self.rootdir
            # this is an ugly hack; we copy our rm and hope it works
            #ensure_dir (rootdir + '/bin')
            #os.path.copyfile ('/bin/rm', rootdir + '/bin/rm')
        # get a list of files and dirs in the root
        files = string.join (os.listdir (self.rootdir))
        self.stdout ('Cleaning out root ...')
        self.do_chroot ('cd / && rm -rfv %s' % files, True)
        os.rmdir (self.rootdir)

    # chroot into root
    def chroot (self, arg):
        print "Entering %s" % self.rootdir
        self.mount ()
        if arg:
             os.system ("%s %s su - root -c '%s'" % (self.config['chroot'], self.rootdir, arg))
        else:
             os.system ("%s %s su - root" % (self.config['chroot'], self.rootdir))
        self.umount ()
     
    def setup (self, arg):
        "Set up the root to a given target"
        target = ''
        if arg:
            target = arg
        else:
            target = 'build' # default to build
        targets = ('prep', 'base', 'consistency', 'build')
    
        # see if something real given to setup
        if target not in targets:
            raise self.Error, "don't know how to set up %s" % target
        self.lock ()
    
        # FIXME: methodize
        debug ("checking packages")
        self.check_bootstrap ()
    
        # try each of the targets in turn
        for which in targets:
            debug ("setting up target %s" % which)
            method = '_setup_' + which
            if method not in Root.__dict__.keys ():
                raise self.Error, "no _setup_%s method" % which
            Root.__dict__[method] (self)
            if target == which:
                break
        self.unlock ()
     
    def rebuild (self, arg):
        (options, paths) = self.splitargsrpms (arg)
        self.setup ('build')
        self.lock ()
        self.config_recreate ('/usr/bin/apt-sigchecker')
        # get pkgs and collect info
        pkgs = {}
        for path in paths:
    	# resolve path to basename (without dirs)
            srpmname = os.path.basename (path)
            newpath = os.path.join (self.rootdir, 'tmp', srpmname)
            try:
                urlgrab (path, newpath)
            except IOError:
                raise self.Error, "Can't find %s" % path
                return False
            srpm = SRPM (newpath)
            spec = srpm.specname
            buildreqs = srpm.BuildRequires ()
            name = srpm.header[rpm.RPMTAG_NAME]
            pkgs[name] = {}
            pkgs[name]['path'] = newpath
            pkgs[name]['buildreqs'] = buildreqs
            pkgs[name]['srpm'] = srpm
            pkgs[name]['srpmname'] = srpmname
            pkgs[name]['header'] = srpm.header
            pkgs[name]['spec'] = spec
     
        # now figure out build order based on buildrequires of each pkg
        deps = [] # list of pkg, dep pairs
        for pkg in pkgs.keys ():
            debug ("Processing %s for build order" % pkgs[pkg]['srpmname'])
            # get results from this package
            results = pkgs[pkg]['srpm'].results ()
            # figure out the build requirements and add
            # pkg -> (results) and buildreq -> (results) to chain
            for result in results:
                if result != pkg:
                    debug ("adding %s depends on pkg %s" % (result, pkg))
                    deps.append ((result, pkg))
                if not pkgs[pkg]['buildreqs']: continue
                for buildreq in pkgs[pkg]['buildreqs']:
                    debug ("adding %s depends on buildreq %s" % (result, buildreq))
                    deps.append ((result, buildreq))
    
        debug ("topological input: ")
        debug (deps)
        debug ("topological output: ")
        sorted = topological_sort (deps)
        sorted.reverse ()
        debug ("order %s" % sorted)
        # now scrub packages not up for build from order
        order = []
        for pkg in sorted:
            if pkg in pkgs.keys ():
                order.append (pkg)
        debug ("(without packages up for build) order %s" % order)
    
        # now make sure all packages given are up for build
        for pkg in pkgs.keys ():
            if pkg not in order:
                order.append (pkg)
        debug ("(with all packages up for build) order %s" % order)
    
        # now build
        self.mount ()
       
        resultdirs = [] # will contain each of the resultdir's for this build
        # loop over all package names
        for name in order:
            srpmname = pkgs[name]['srpmname']
            print "Building %s" % srpmname
            sys.stdout.write ('Installing BuildRequires ...')
            try:
                self.aptget ('install -y %s' % string.join (pkgs[name]['buildreqs']), True)
            except Root.Error:
                sys.stderr.write ('Cannot build %s\n' % srpmname)
                #continue
                #FIXME: error code was never returned
                #raise self.Error, "something went wrong building SRPM"
                self.unlock()
                sys.exit (1)

            # get the name and create the place where to store results
            h = pkgs[name]['header']
            name = h[rpm.RPMTAG_NAME]
            version = h[rpm.RPMTAG_VERSION]
            release = h[rpm.RPMTAG_RELEASE]
            # if the release tag needs mangling, do it here as well
            if self.config['release']:
                fullname = '%s-%s-%s.%s' % (name, version, release,
                                            self.config['release'])
            else:
                fullname = '%s-%s-%s' % (name, version, release)
            resultdir = os.path.join (self.resultdir, fullname)
            ensure_dir (resultdir)
            # rebuild binary rpm from the src rpm
            sys.stdout.write ("Rebuilding %s ..." % srpmname)
            #newpath = os.path.join (self.rootdir, 'tmp', srpm)
            #self.rpm ("-Uhv --nodeps %s" % newpath)
            # install the src.rpm
            self.do_chroot ("su -c 'rpm -Uhv /tmp/%s' machbuild" % srpmname)
            spec = pkgs[name]['spec']

            # mangle spec file if requested
            if self.config['release']:
                command = 'cp /usr/src/rpm/SPECS/%s /tmp/%s' % (spec, spec)
                self.do_chroot (command)
                command = 'sed -e "s,Release.*,&.%s,g" /tmp/%s > /usr/src/rpm/SPECS/%s' % (self.config['release'], spec, spec)
                self.do_chroot (command)
                command = 'rm /tmp/%s' % spec
                self.do_chroot (command)

            # rebuild from spec inside chroot
            command = "su -c 'rpmbuild -ba --nodeps %s /usr/src/rpm/SPECS/%s 2>&1' machbuild" % (string.join (options), spec)
            (status, output) = self.do_chroot (command, True)
            if (output):
                open (resultdir + '/rpm.log', "wb"). write (output)
            if status != 0:
                sys.stderr.write ("ERROR: something went wrong building this one\n")
                sys.stderr.write ("ERROR: inspect rpm build log %s/rpm.log\n" % resultdir)
                self.umount ()
                self.unlock ()
                return False
            # reinstall and repackage src rpm
            #sys.stdout.write ("Repackaging %s ..." % srpm)
            #do_chroot (config, '%s -Uhv /tmp/%s > /dev/null 2>&1' % (chroot_rpm, srpm))
            #do_chroot (config, "su -c 'rpm -Uhv /tmp/%s > /dev/null 2>&1' mach" % srpm)
            #self.rpm ('-Uhv /tmp/%s > /dev/null 2>&1' % srpm)
            #(status, output) = do_chroot_with_output (config,
            # "su -c 'rpmbuild -bs --nodeps /usr/src/rpm/SPECS/%s 2>&1' mach" % spec,
            #    True)
            if output:
                open (resultdir + '/rpm.log', "ab"). write (output)
            if status != 0:
                raise self.Error, "something went wrong repackaging SRPM"
    
            # analyze log file and move all of the rpms listed as Wrote:
            (srpm, rpms) = get_rpms_from_log (resultdir + '/rpm.log')
            # FIXME: install these RPMS based on a boolean ?
            # FIXME: error checks
            output = self.rpm ('-qp --qf "%%{name}=%%{epoch}:%%{version}-%%{release} " %s' % string.join (['', ] + rpms, " " + self.rootdir))
            #(status, output) = do_chroot_with_output (config, '%s -qp --qf "%%{name}=%%{epoch}:%%{version}-%%{release} " %s' % (chroot_rpm, string.join (rpms, " ")))
            # FIXME: don't install built packages automatically, they can
            # cause conflicts and break sequence builds
            # Need to handle packages without Epochs :/
            # output = string.replace (output, '=(none):', '=');
            #sys.stdout.write ("Installing built RPMS and dependencies ...")
            #self.aptget ("install -y %s" % output, True)
            print "Collecting results of build %s" % srpm
            rpms.append (srpm)
            for file in rpms:
                path = self.rootdir + file
                # file already contains starting /
                shutil.copy2 (path, resultdir)
                # for now, we do, for multiple builds
                # self.do_chroot ('rm ' + file)
            # update internal apt repo
            self.aptget ("update")
            print "Build of %s succeeded, results in\n%s" % (fullname, resultdir)
            resultdirs.append (resultdir)

        # md5sum packages
        for resultdir in resultdirs:
	    cmd = 'cd %s && md5sum *.rpm > md5sum' % resultdir
            debug ("running %s" % cmd)
            os.system (cmd)
        # now sign packages if requested
        if self.config['sign']:
            print "Signing built packages ..."
            cmd = 'rpm --addsign %s' % string.join (resultdirs, '/*.rpm ') + '/*.rpm' 
            debug ("running %s" % cmd)
            os.system (cmd)
            #FIXME: sadly, we cannot clearsign multiple files ?
            print "clearsigning md5sums ..."
            for resultdir in resultdirs:
                if os.path.exists (os.path.join (resultdir, 'md5sum.asc')):
                    os.unlink (os.path.join (resultdir, 'md5sum.asc'))
		cmd = 'cd %s && md5sum *.rpm > md5sum' % resultdir
                debug ("running %s" % cmd)
                os.system (cmd)
		cmd = 'gpg --use-agent --clearsign %s/md5sum' % resultdir
                debug ("running %s" % cmd)
                os.system (cmd)

        # now collect stuff to . if requested
        if self.config['collect']:
            for resultdir in resultdirs:
               for x in glob.glob (os.path.join (resultdir, '*.rpm')):
                   os.system ('mv %s %s' % (x, os.path.basename (x)))
               for x in glob.glob (os.path.join (resultdir, '*')):
                   os.system ('mv %s %s.%s' % (x, name, os.path.basename (x)))
            
        print "Build done."

        # sign all packages at once so we only need the passphrase once
        # FIXME: repeat if fail

        # collect all packages if requested

        self.umount ()
        self.unlock ()
        
    # private methods
    def _setup_prep (self):
        "prepares a given root if not done yet; this ensures that a number"
        "continue of necessary files exist in the root"
        if self.get_state ('prep'): return
    
        print "Preparing root ..."
        ensure_dir (os.path.join (self.rootdir, 'etc', 'apt'))
        ensure_dir (os.path.join (self.rootdir, 'var', 'lib', 'rpm'))
        #FIXME: os.chmod (root + '/var/lib/rpm', g+s)
        ensure_dir (os.path.join (self.rootdir, 'dev'))
        #FIXME: create /dev/null or install dev rpm later on
        #os.system ('%s %s c 1 3' % (config['mknod'],
        #                            os.path.join (self.rootdir, 'dev', 'null'))
        ensure_dir (os.path.join (self.rootdir, 'etc'))
        open (os.path.join (self.rootdir, 'etc', 'mtab'), 'w')
        open (os.path.join (self.rootdir, 'etc', 'fstab'), 'w')
        ensure_dir (os.path.join (self.rootdir, 'tmp'))
        ensure_dir (os.path.join (self.rootdir, 'var', 'tmp'))
    
        # create a custom apt.conf file
        root = self.rootdir
        conf = '''
// apt.conf generated by mach

#clear RPM::Pre-Install-Pkgs; // this makes sure packages don't get checked

APT {
    Clean-Installed "false";
    Get {
        Assume-Yes "false";
        Download-Only "false";
        Show-Upgraded "true";
        Fix-Broken "false";
        Ignore-Missing "false";
        Compile "false";
    };
};
                                                                                
Acquire {
    Retries "0";
    Http {
        Proxy ""; // http://user:pass@host:port/
    }
};

RPM {
    Ignore { };
    Hold { };
    Allow-Duplicated { "^kernel$"; "^kernel-"; "^alsa-kernel"; "^gpg-pubkey$" };     Source {
        Build-Command "rpmbuild --rebuild";
    };
    RootDir "''' + root + '''";
    Options "--root ''' + root + '''";
    Install-Options "--root ''' + root + '''";
    Erase-Options "--root ''' + root + '''";
}
Dir {
     Etc "''' + os.path.join (root, 'etc', 'apt') + '''";
     Cache "''' + os.path.join (root, 'var', 'cache', 'apt') + '''";
     State "''' + os.path.join (root, 'var', 'state', 'apt') + '''";
}
'''
        self.set_state ("apt.conf", conf)
    
        # write state file
        self.set_state ("prep")
    
    def _setup_base (self):
        self._install ('base')
    def _setup_consistency (self):
        "forces consistency on root by triggering an apt-get update"
        if self.get_state ('consistency'): return
        self.mount ()

        rootdir = self.rootdir
        config = self.config
        srcs = get_sources_list (config)

        # create all needed configfiles
        debug ("Creating config files")
        for filename in self.config['files'].keys ():
            self.config_recreate (filename)
    
        # rebuild the rpm database using the installed rpm before messing
        # do_chroot (config, "rpm --rebuilddb")
        # first create a sources.list with only the first sources line
        # this ensures glibc doesn't get upgraded from underneath apt
        create_sources_list (config, srcs)
        self.stdout ('Updating apt using all sources ...')
        self.aptget ("update", True)
        self.stdout ('Forcing consistency and upgrading ...')
        self.aptget ("-f upgrade -y", True)
        self.set_state ('consistency')

    def _setup_build (self):
        "set up a root for rpm building"
        if self.get_state ('build'):
            # see if we need to revert to the given state
            # FIXME: methodify
            statefile = os.path.join (self.statedir, 'build')
            self.check_package_list (statefile)
            return
        #statefile = get_config_dir (config, 'state') + '/build'
        self.mount ()
        # install packages
        sys.stdout.write ('Installing rpm build packages ...')
        self.aptget ('install -y %s' % self.config['packages']['build'], True)
        #FIXME: add mach user and group
        self.do_chroot ("echo machbuild:!!:500:500::/usr/src/rpm:/bin/bash >> /etc/passwd")
        self.do_chroot ("echo machbuild::500:mach >> /etc/group")
        self.do_chroot ("mkdir -p /usr/src/rpm")
        self.do_chroot ("chown -R machbuild:machbuild /usr/src/rpm")
        self.do_chroot ("su -c 'cp -p /etc/skel/.bashrc /usr/src/rpm/.bashrc || cp -p /etc/bashrc /usr/src/rpm/.bashrc || :' machbuild")
         # create dir structure and rpmmacros
        macros = open (self.rootdir + '/tmp/macros', 'w')
        macros.write ("%_topdir /usr/src/rpm\n")
        macros.write ("%_rpmfilename %%{NAME}-%%{VERSION}-%%{RELEASE}.%%{ARCH}.rpm\n")
        macros.write ("%_unpackaged_files_terminate_build 1\n")
        macros.write ("%_missing_doc_files_terminate_build 1\n")
        macros.close ()
        self.do_chroot ('mv /tmp/macros /etc/rpm')
        for dir in ('RPMS', 'SRPMS', 'SOURCES', 'SPECS', 'BUILD'):
            self.do_chroot ("su -c 'mkdir -p /usr/src/rpm/%s' machbuild" % dir)
    
        # this ensures that locally built RPMS are already used for apt-get
        srcs = get_sources_list (self.config)
        # FIXME: if we use external apt then this path should be changed ?
        # FIXME: and if not ?
        #srcs.insert (0, 'rpm-dir file:///usr/src rpm mach-local')
        srcs.insert (0, 'rpm-dir file://%s/usr/src rpm mach-local' % self.rootdir)
        create_sources_list (self.config, srcs) 
        for dir in ('RPMS', 'SRPMS'):
            self.do_chroot ('ln -sf %s /usr/src/rpm/%s.mach-local' % (dir, dir))
        self.aptget ("update")

        self.stdout ("Making snapshot ...\n")
        # FIXME: use _with_output for this
        output = self.rpm ("-qa --qf %s" % qfmt)
        self.set_state ('build', output)
        self.umount ()
    
    def _install (self, set):
        "installs the given set of packages into the root.  Packages live "
        "in packagesdir.  This is used by _setup_base and _setup_apt"
        debug ("_install (%s)" % set)
        if self.get_state (set): return
        debug ("Installing set of packages in %s" % set)
        # expand path for each package and install all of them at once
        # a roundabout way to prefix each rpm in the list with the path
        rpms = string.join (('', ) + self.config['packages'][set],
                            ' ' + self.packagesdir + '/')
        #command = '%s --root %s -Uhv %s --nodeps --noorder --replacepkgs' % (config ['rpm'], root, rpms)
        # if config['rpm'] has sudo, that's one too many for cleanliness
        # FIXME: this is a terribly dangerous hack.  We use chroot / so that we
        # can execute an arbitrary command (in this case, the extracted rpm)
        # with root privileges.  Please move this to a mach-helper binary !
        #command = "%s / /bin/bash -c 'export LD_ASSUME_KERNEL=2.2.5 && %s --root %s -Uhv %s --nodeps --noorder --replacepkgs'" % (config['chroot'], get_rpm (config), root, rpms)
        command = "%s --root %s -Uhv %s --nodeps --noorder --replacepkgs" % (self.config['rpm'], self.rootdir, rpms)
        debug ("Executing %s" % command)
        self.stdout ("Installing %s packages ..." % set)
        (status, output) = do_progress (command)
        #print "DEBUG: status %d output %s\n" % (status, output)
        if status != 0:
            raise self.Error, "Could not install package set %s, status %s" % (set, status)
        self.set_state (set)
     
### helper functions

# return path to rpm binary suited to our target root, extracting it if
# necessary
# FIXME: this function is not used right now, would it be a good idea to
# do so in the future ?
def get_rpm (config):
    debug ("getting rpm for root %s" % config['root'])
    tmpdir = get_config_dir (config, 'tmp')
    binary = os.path.join (tmpdir, 'bin', 'rpm')
    
    # first check if it exists yet
    if os.path.exists (binary): return binary

    # it doesn't, so get it
    packagesdir = get_packages_dir (config)
    # find rpm package in 'base' set
    packages = config['packages']['base']
    matchstr = re.compile ("^rpm-\d")
    rpm = ""
    for package in packages:
        if matchstr.search (package):
            rpm = package
    if not rpm:
        sys.stderr.write ("Could not find rpm in base set !\n")
        exit (config)
    print "Found rpm %s" % rpm
    # check if it exists
    path = os.path.join (packagesdir, rpm)
    if not os.path.exists (path):
        sys.stderr.write ("Could not find file %s !\n" % path)
        exit (config)
    # extract rpm binary from it
    ensure_dir (tmpdir)
    command = "cd %s && rpm2cpio %s | cpio -id --no-absolute-filenames bin/rpm > /dev/null" % (tmpdir, path)
    if os.system (command) != 0:
        sys.stderr.write ("Could not extract rpm binary from package !\n")
        exit (config)
    return binary
    
# grab given url and store it as filename, preserving timestamps
def urlgrab (url, filename):
    print "Getting %s ..." % url
    (t, h) = urllib.urlretrieve (url, filename)
    d = None
    try:
        if h:
            d = time.mktime (h.getdate ("Last-Modified") or h.getdate ("Date"))
        if d:
            os.utime (filename, (d, d))
    except:
        sys.stderr.write ("Warning: time stamp not preserved for %s\n" % filename)


# unlock and exit
def exit (config):
    unlock (config)
    sys.exit (1)

# run a command, opening a pty and returning fd and pid
def pty_popen (cmd):
    pid, fd = os.forkpty ()
    if pid == 0:
        os.execl ('/bin/sh', 'sh', '-c', cmd)
        
    else:
        return os.fdopen (fd), pid

# run a command and give a progress spinner that regularly advances
# delta gives the number of secs between each spin iteration
# jump is the number of iterations before jumping one dot further
# returns a tuple:
# - the return status of the app
# - all of the output as one big string
def do_progress (cmd, delta = 0.1, jump = 20):
    # choose a random spinner by jumping through lots of hoops
    spinkey = random.randint (0, len (config['spinner'].keys ()) - 1)
    spinner = config['spinner'][config['spinner'].keys ()[spinkey]]
    i = 0 # jump counter
    j = 0 # spinner state
    timestamp = time.time ()
    running = 1
    size = 0 # size of total output since last spinner update
    output = []
    (fdin, pid) = pty_popen (cmd)
    fcntl.fcntl (fdin, fcntl.F_SETFL, os.O_NONBLOCK) # don't block input
    sys.stdout.write (spinner[0])
    sys.stdout.flush () # otherwise we don't see nothing until first update
    while running:
        block = ""
        try:
            block = fdin.read ()
            # trash all \r\n
            block = string.replace (block, '\r\n', '\n')
            output.append (block)
        except IOError:
            pass
        size = size + len (block)
        if size > 0 and time.time () > timestamp + delta:
            timestamp = time.time ()
            size = 0
            i = i + 1
            j = (j + 1) % len (spinner)
            sys.stdout.write ('\b' + spinner[j % len (spinner)])
            if (i > jump):
                i = 0
                sys.stdout.write ('\b.%s' % spinner[j])
            sys.stdout.flush ()
        time.sleep (0.1)
        try:
            (dip, status) = os.waitpid (pid, os.WNOHANG)
        except OSError:
            running = 0

    # done
    output = string.join (output, '').split ("\n")
    retval = 0
    if os.WIFEXITED (status):
        retval = os.WEXITSTATUS (status)
    if (retval != 0):
        sys.stdout.write ('\b!\n')
        sys.stderr.write ('error: %s failed.\n %s\n' % (cmd, string.join (output, "\n")))
    else: 
        sys.stdout.write ('\b.\n')
    return (retval, string.join (output, '\n'))

# execute the given command; possibly with progress bar
# return (return value, output) of command
def do_with_output (command, progress = False):
    debug ("Executing %s" % command)
    if progress:
        return do_progress (command)
    else:
        (status, output) = commands.getstatusoutput (command)

    if os.WIFEXITED (status):
        retval = os.WEXITSTATUS (status)
    #if (retval != 0):
    #    sys.stdout.write ('\b!\n')
        #sys.stderr.write ('error:\n %s' % string.join (output))
    #else:
    #    sys.stdout.write ('\b.\n')
    #FIXME: hack to return no output, we should change this
    if (retval != 0):
        sys.stderr.write ("error: %s failed\n" % command)
    return (retval, output)

# do a topological sort on the given list of pairs
# taken from a mail on the internet and adapted
# given the list of pairs of X needed for Y, return a suggested build list

class CycleError(Exception): pass
def topological_sort (pairlist):
    numpreds = {}   # elt ->; # of predecessors
    successors = {} # elt -> list of successors
    for first, second in pairlist:
        # make sure every elt is a key in numpreds
        if not numpreds.has_key (first):
            numpreds[first] = 0
        if not numpreds.has_key (second):
            numpreds[second] = 0
                                                                                
        # since first < second, second gains a pred ...
        numpreds[second] = numpreds[second] + 1
                                                                                
        # ... and first gains a succ
        if successors.has_key (first):
            successors[first].append (second)
        else:
            successors[first] = [second]
                                                                                
    # suck up everything without a predecessor
    answer = filter (lambda x, numpreds=numpreds:
                         numpreds[x] == 0, numpreds.keys())
                                                                                
    # for everything in answer, knock down the pred count on
    # its successors; note that answer grows *in* the loop
    for x in answer:
        del numpreds[x]
        if successors.has_key (x):
            for y in successors[x]:
                numpreds[y] = numpreds[y] - 1
                if numpreds[y] == 0:
                    answer.append (y)
            # following "del" isn't needed; just makes
            # CycleError details easier to grasp
            del successors[x]
                                                                                
    if numpreds:
        # everything in numpreds has at least one successor ->
        # there's a cycle
        raise CycleError, (answer, numpreds, successors)
    return answer

# get a header from a path to a local src.rpm; or False if no header
def get_header (path):
    debug ("Getting RPM header from %s" % path)
    # ignore signatures
    ts = rpm.TransactionSet ("", (rpm._RPMVSF_NOSIGNATURES))
    fd = os.open (path, os.O_RDONLY)
    try:
        h = ts.hdrFromFdno (fd)
    except:
        print "a whoopsie occurred."
    if not h:
        sys.stderr.write ("ERROR: %s doesn't look like a .src.rpm\n" % path)
        return False
    return h

# get all of the written rpms from the log file and return a tuple
# srpm, list of rpms
def get_rpms_from_log (log):
    rpms = []
    srpm = ''
    matchstr = re.compile ("src\.rpm$")
    output = commands.getoutput ('grep "Wrote: " %s | sort | uniq' % log)
    for line in output.split ("\n"):
        curr = string.replace (line, 'Wrote: ', '')
        if matchstr.search (curr):
            srpm = curr
        else:
            rpms.append (curr)
    return (srpm, rpms)

# print out debug info if wanted
# uses DEBUG global
def debug (string):
    if DEBUG:
        print "DEBUG: %s" % string

# return full path to directory based on the root (in config) and which sort
# of directory to get
def get_config_dir (config, which):
#FIXME: do error checking on key
    return config['dirs'][which + 's'] + '/' + config['root']

# return full path to directory holding bootstrap packages for this root
# DELETEME
def get_packages_dir (config):
    return config['dirs']['packages'] + '/' + config['packages']['dir']

# make sure a dir exists
def ensure_dir (dir):
    if not os.path.exists (dir):
        try:
            os.makedirs (dir)
        except OSError:
            sys.stderr.write ("Could not create %s, make sure you have permissions to do so\n" % dir)
            sys.exit (1)

# get the list of sources.list lines based on the config
# based on sourceslist dict
def get_sources_list (config):
    sourceslist = []
    root = config['root']
    for platform in config['sourceslist'][root].keys ():
        for source in config['sourceslist'][root][platform]:
            sourceslist.append (config['aptsources'][platform][source])

    debug ("sources.list: " + string.join (sourceslist, "\n"))
    return sourceslist

# create sources.list file by putting the given list of lines in it
def create_sources_list (config, list):
    root = get_config_dir (config, 'root')
    statedir = get_config_dir (config, 'state')
    debug ("Creating sources.list")
    # we created in the root and chroot mv it afterwards due to perms
    sources = open (statedir + '/apt@SYSCONFDIR@/apt/sources.list', 'w')
    sources.write (string.join (list, "\n"))
    sources.close ()
#    os.system ('%s %s mv /tmp/sources.list @SYSCONFDIR@/apt' % (config['chroot'], root))
    

# lock a given root; creates a lock file in the statedir under root
def lock (config):
    statedir = get_config_dir (config, 'state')
    ensure_dir (statedir)
    lockpath = statedir + '/lock'
    if os.path.exists (lockpath):
        if not config['force']:
            sys.stderr.write ('error: %s already locked !\n' % config['root'])
            return False
        else:
            print 'warning: overriding lock on root %s' % config['root']
    try:
        lockfile = open (lockpath, 'w')
    except:
        sys.stderr.write ('error: can''t create lock file for %s !\n' % config['root'])
        return False
    lockfile.close ()
    return True
        
# unlock a given root; removes lock file in the statedir under root
def unlock (config, notused=0):
    statedir = get_config_dir (config, 'state')
    lockpath = statedir + '/lock'
    if os.path.exists (lockpath):
        os.remove (lockpath)
        return True
    else:
        sys.stderr.write ('error: %s not locked !\n' % config['root'])
        return False
     
# return the state, or nothing if state isn't there
def get_state (config, state):
    statedir = get_config_dir (config, 'state')
    if os.path.exists (statedir + '/' + state):
        return statedir + '/' + state
    return

# check the given package list file
# remove all packages that aren't in this list file
def check_package_list (config, list):
    debug ("checking package list against snapshot")
    if config.has_key ('keep'):
        print "Not removing packages from root."
        return True
    root = get_config_dir (config, 'root')
    cmd = 'rpm --root %s -qa --qf %s | diff - %s > /dev/null 2>&1' % (root,
                                                                      qfmt,
                                                                      list)
    debug ("running " + cmd)
    if os.system (cmd) == 0:
        # no differences
        return True
    cmd = "rpm --root %s -qa --qf %s | grep -v -f %s - | tr '\n' ' '" % (root,
                                                                         qfmt,
                                                                         list)
    packages = commands.getoutput (cmd)
    # FIXME: how many ?
    sys.stdout.write ("Removing packages ...")
    if not packages:
       print "Error: packages was empty"
       return True
    self.rpm ("-ev %s" % packages, True)
    return True

# check if everything is in order to actually do stuff
def sanity_check (config):
    # check if we're in the mach group
    if os.getuid () != 0:
        machgid=grp.getgrnam ('mach')[2]
        if not machgid in os.getgroups():
            sys.stderr.write ("error: user is not in group mach, please add !\n")
            sys.exit (1)

    # check if partial dir exists
    partial = config['dirs']['archives'] + '/partial'
    ensure_dir (partial)

    # check if mach-helper is suid
    if not (os.stat ('@SBINDIR@/mach-helper')[0] & stat.S_ISUID):
        sys.stderr.write ("error: @SBINDIR@/mach-helper is not setuid !\n")
        sys.exit (1)

    # we're fine
    return True

   
# forcibly check packages
def check (config, args):
    # force package check
    config['check'] = 1
    if check_packages (config):
        print "Everything ok."

# give a status of each of the roots
def status (config, args):
    print "FIXME: write me" 

# main function
def main (config, args):
    global DEBUG # we might change it
    try:
        opts, args = getopt.getopt (args, 'r:hdfksc',
                                    ['root=', 'help', 'debug', 'force', 'keep',
                                     'sign', 'collect', 'release='])
    except getopt.error, exc:
        sys.stderr.write ('error: %s\n' % str (exc))
        sys.exit (1)

    # parse environment
    try:
        root = os.environ['MACH_ROOT']
    except:
        root = config['defaultroot']

    # parse config options
    for opt, arg in opts:
        if opt in ('-h', '--help'):
            print usage
            print help
            sys.exit (0)
        elif opt in ('-r', '--root'):
            root = arg
        elif opt in ('-d', '--debug'):
            DEBUG = 1
        elif opt in ('-f', '--force'):
            config['force'] = 1
        elif opt in ('-k', '--keep'):
            config['keep'] = 1
        elif opt in ('-s', '--sign'):
            config['sign'] = 1
        elif opt in ('-c', '--collect'):
            config['collect'] = 1
        elif opt == '--release':
            config['release'] = arg

    # pull in root-specific configuration
    # FIXME: even nicer would be if we could just do config[rootname] = ...
    # and copy that over
    try:
        config['packages'] = packages[root]
    except KeyError:
        sys.stderr.write ('No definition for packages found for %s\n' % root)
        sys.exit (1)
    try:
        config['aptsources'] = aptsources
        config['sourceslist'] = sourceslist
    except KeyError:
        sys.stderr.write ('No sources information found for %s\n' % root)
        sys.exit (1)
    #try:
    #    config['files'] = files[root]
    #except:
    #    debug ("no files override")

    if config.has_key (root):
        for key in config[root].keys ():
            debug ("setting config['%s'] to %s" % (key, config[root][key]))
            config[key] = config[root][key]

    # debug output options
    debug ("root: %s" % root)

    # process options
    config['root'] = root

    # check if everything is ready to go
    sanity_check (config)

    # DEBUG DEBUG DEBUG:
    #get_sources_list (config)
    #rpms = get_rpms_from_log ('/home/thomas/prefix/var/tmp/mach/result/redhat-9-i386/drwright-0.16-0.fdr.1/rpm.log')
    #do_progress ("dmesg && sleep 1 && dmesg && sleep 1 && dmesg && true")
    #do_progress ("dmesg && sleep 1 && dmesg && sleep 1 && dmesg && false")
    #binary = get_rpm (config)
    #print "rpm binary: %s" % binary

    #sys.exit (0)

    # run command
    if not args:
        print usage
        print help
        sys.exit (1)
    command = args[0]
    args = string.join (args[1:])
    debug ("main: running %s" % command)
    
    root = Root (config)
    output = ""
    if command in allowed_commands:
        # this is silly but what can we do about it ?
        if command == "apt-get": command = "aptget"
        if command == "apt-cache": command = "aptcache"
        try:
            output = Root.__dict__[command] (root, args)
        except KeyError:
            sys.stderr.write ("No %s method defined\n" % command)
        except Root.Locked:
            sys.stderr.write ("Root is locked.  Use -f to override lock\n")
        except Root.Error, message:
            sys.stderr.write ("%s\n" % message)
            root.unlock ()
        except Root.ReturnValue, retval:
            sys.stderr.write ("Return value: %s\n" % retval)
            root.unlock ()
        if output:
            print output
    else:
        sys.stderr.write ("No such command '%s'\n" % command)
    #try:
    #globals()[command](config, args)
    #except:
    #    sys.stderr.write ('mach: unsupported command %s\n' % command)
    #    sys.exit (1)

# run main program

if __name__ == '__main__':
    # run command specified or go into interpreter mode
    if len (sys.argv) > 1:
        main (config, sys.argv[1:])
    else:
        print "starting mach interpreter ..."
        running = True;
        while running:
            sys.stdout.write ("> ")
            command = sys.stdin.readline ()
            main (string.split (command))

    
