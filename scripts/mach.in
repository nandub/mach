#!/usr/bin/python
#
# mach - make a chroot
#
# script to set up a chroot using packages and optionally perform builds in it

import sys, os, getopt, string, commands, urllib, shutil, time, fcntl, re
import rpm # FIXME: find out what rpm version we need !
import random # spinner theming madness

# FIXME: move this to config
chroot_aptget = 'export LD_ASSUME_KERNEL=2.2.5 && apt-get'
chroot_rpm = 'export LD_ASSUME_KERNEL=2.2.5 && rpm'

# make sure True and False constants exist

if not hasattr (__builtins__, 'True'):
    __builtins__.True = (1 == 1)
    __builtins__.False = (1 != 1)

# usage and help
usage = 'usage: mach [ -r root ] command [ options ... ]'
help = '''Make a chroot and do stuff in it.

Global options:
  -r, --root=ROOT		specify a root to work in
  -d, --debug			turn on debugging
  -f, --force			override root lock
  -k, --keep			do not revert buildroot to initial package list

Commands:
  build				build from (set of) .spec file(s)
  chroot			chroot into root
  clean				totally cleans the root
  check				check if a root can be set up
  rebuild			rebuild a (set of) .src.rpm(s)
  setup				sets up the root for a particular purpose
        prep                         preparation before package install
        base                         base set of rpms to make rpm work
        apt                          base set of rpms to make apt work
        consistency                  internally consistent install
        build                        everything to build rpms
  status			show status of mach roots
  unlock			override root lock
'''

# read default configuration
config = {
  'force': 0,
  'check': 0,
  'defaultroot': 'redhat-9-i386', # FIXME: based on configure's distro check

  'chroot': 'sudo -H /usr/sbin/chroot',
  'mount': 'sudo -H /bin/mount',
  'rpm': 'sudo -H /bin/rpm',
  'umount': 'sudo -H /bin/umount',

}
DEBUG = 0

# read system-wide configuration
file = '@SYSCONFDIR@/mach/conf'
execfile (file)

# read package information
packages = {}
file = '@SYSCONFDIR@/mach/packages'
execfile (file)

# read apt information
aptsources = {}
sourceslist = {}
file = '@SYSCONFDIR@/mach/apt'
execfile (file)

# read user configuration
file = os.path.join (os.environ['HOME'], '.machrc')
try:
    execfile (file)
except IOError:
    pass

# list of allowed commands
allowed_commands = ('build', 'check', 'chroot', 'clean', 'rebuild',
                    'setup', 'status', 'unlock')

# rpm -q format, users may have customized %_query_all_fmt in ~/.rpmmacros...
qfmt = '"%{name}-%{version}-%{release}\n"'

### objects
class Spec:
    def __init__ (self, path):
        self.path = path
        self.content = []
        self.vars = {}
        self.content = open (self.path).readlines ()
        for which in ['name', 'version', 'release']:
            self.vars[which] = self.tag (which)

    def tag (self, which):
        "Get the given (unique) tag from the spec file as a string"
        if self.vars.has_key (which):
            return self.vars[which]

        matchstr = re.compile ("^" + which + r"\d*:\s*(.*)", re.I)
        for line in self.content:
            match = matchstr.search (line)
            if match:
                value = match.expand ("\\1")
                self.vars[which] = value
                return value
        return None

    def tags (self, which):
        "Get all given tags from the spec file as a list"
        result = []
        matchstr = re.compile ("^" + which + r"\d*:\s*(.*)", re.I)
        for line in self.content:
            match = matchstr.search (line)
            if match:
                value = match.expand ("\\1")
                result.append (value)
        return result

    # this is done quick and dirty, could be optimized more
    def expand (self, expression):
        "expand a line from a spec file using vars from the spec file"
        for variable in self.vars.keys ():
            expression = string.replace (expression, "%{" + variable + "}",
                                         self.vars[variable])
        #print "DEBUG: expanded to %s" % expression
        return expression

    def nvr (self):
        "return name, version, release triplet"
        return (self.vars['name'], self.vars['version'], self.vars['release'])
 

    # make this private
    def sourcespatches (self, which):
        result = {}
        matchstr = re.compile ("^(" + which + r"\d*):\s*(.*)")
        for line in self.content:
            match = matchstr.search (line)
            if match:
                tag = match.expand ("\\1")
                value = match.expand ("\\2")
                result[tag] = self.expand (value)
        return result
 
    def sources (self):
           # parse the spec file for all Source: files
           return self.sourcespatches ("Source")

    def patches (self):
           # parse the spec file for all Source: files
           return self.sourcespatches ("Patch")
 
### helper functions

def urlgrab (url, filename):
    print "Getting %s ..." % url
    (t, h) = urllib.urlretrieve (url, filename)
    d = None
    try:
        if h:
            d = time.mktime (h.getdate ("Last-Modified") or h.getdate ("Date"))
        if d:
            os.utime (filename, (d, d))
    except:
        print "Warning: time stamp not preserved for %s" % filename


# unlock and exit
def exit (config):
    unlock (config)
    sys.exit (1)

# run a command, opening a pty and returning fd and pid
def pty_popen (cmd):
    pid, fd = os.forkpty ()
    if pid == 0:
        os.execl ('/bin/sh', 'sh', '-c', cmd)
        
    else:
        return os.fdopen (fd), pid

# run a command and give a progress spinner that regularly advances
# delta gives the number of secs between each spin iteration
# jump is the number of iterations before jumping one dot further
# returns a tuple:
# - the return status of the app
# - all of the output as one big string
def do_progress (cmd, delta = 0.1, jump = 20):
    # choose a random spinner by jumping through lots of hoops
    spinkey = random.randint (0, len (config['spinner'].keys ()) - 1)
    spinner = config['spinner'][config['spinner'].keys ()[spinkey]]
    i = 0 # jump counter
    j = 0 # spinner state
    timestamp = time.time ()
    running = 1
    size = 0 # size of total output since last spinner update
    output = []
    (fdin, pid) = pty_popen (cmd)
    fcntl.fcntl (fdin, fcntl.F_SETFL, os.O_NONBLOCK) # don't block input
    sys.stdout.write (spinner[0])
    sys.stdout.flush () # otherwise we don't see nothing until first update
    while running:
        block = ""
        try:
            block = fdin.read ()
            # trash all \r\n
            block = string.replace (block, '\r\n', '\n')
            output.append (block)
        except IOError:
            pass
        size = size + len (block)
        if size > 0 and time.time () > timestamp + delta:
            timestamp = time.time ()
            size = 0
            i = i + 1
            j = (j + 1) % len (spinner)
            sys.stdout.write ('\b' + spinner[j % len (spinner)])
            if (i > jump):
                i = 0
                sys.stdout.write ('\b.%s' % spinner[j])
            sys.stdout.flush ()
        time.sleep (0.1)
        try:
            (dip, status) = os.waitpid (pid, os.WNOHANG)
        except OSError:
            running = 0

    # done
    output = string.join (output, '').split ("\n")
    retval = 0
    if os.WIFEXITED (status):
        retval = os.WEXITSTATUS (status)
    if (retval != 0):
        sys.stdout.write ('\b!\n')
        sys.stderr.write ('error: %s failed.\n %s\n' % (cmd, string.join (output, "\n")))
    else: 
        sys.stdout.write ('\b.\n')
    return (retval, string.join (output, '\n') + '\n')

# execute the given command in the chroot; possibly with progress bar
# return return value of actual shell command
def do_chroot (config, command, progress = False):
    (retval, output) = do_chroot_with_output (config, command, progress)
    return retval

# execute the given command in the chroot; possibly with progress bar
# return (return value, output) of command
def do_chroot_with_output (config, command, progress = False):
    root = get_config_dir (config, 'root')
    # HACK: FIXME: 
    # if the cmd already contains -c ' as a sequence, then don't wrap
    # it in /bin/bash
    
    cmd = ""
    if string.find (command, "-c '") > -1:
        cmd = "%s %s %s" % (config['chroot'], root, command)
    else:
        cmd = "%s %s /bin/bash -c '%s'" % (config['chroot'], root, command)
    output = ''
    debug ("Executing %s" % cmd)
    if progress:
        return do_progress (cmd)
    else:
        (status, output) = commands.getstatusoutput (cmd)

    if os.WIFEXITED (status):
        retval = os.WEXITSTATUS (status)
    #if (retval != 0):
    #    sys.stdout.write ('\b!\n')
        #sys.stderr.write ('error:\n %s' % string.join (output))
    #else:
    #    sys.stdout.write ('\b.\n')
    #FIXME: hack to return no output, we should change this
    if (retval != 0):
        sys.stderr.write ("error: %s failed\n" % cmd)
    return (retval, output)


# do a topological sort on the given list of pairs
# taken from a mail on the internet and adapted
# given the list of pairs of X needed for Y, return a suggested build list

def topological_sort (pairlist):
    numpreds = {}   # elt ->; # of predecessors
    successors = {} # elt -> list of successors
    for first, second in pairlist:
        # make sure every elt is a key in numpreds
        if not numpreds.has_key (first):
            numpreds[first] = 0
        if not numpreds.has_key (second):
            numpreds[second] = 0
                                                                                
        # since first < second, second gains a pred ...
        numpreds[second] = numpreds[second] + 1
                                                                                
        # ... and first gains a succ
        if successors.has_key (first):
            successors[first].append (second)
        else:
            successors[first] = [second]
                                                                                
    # suck up everything without a predecessor
    answer = filter (lambda x, numpreds=numpreds:
                         numpreds[x] == 0, numpreds.keys())
                                                                                
    # for everything in answer, knock down the pred count on
    # its successors; note that answer grows *in* the loop
    for x in answer:
        del numpreds[x]
        if successors.has_key (x):
            for y in successors[x]:
                numpreds[y] = numpreds[y] - 1
                if numpreds[y] == 0:
                    answer.append (y)
            # following "del" isn't needed; just makes
            # CycleError details easier to grasp
            del successors[x]
                                                                                
    if numpreds:
        # everything in numpreds has at least one successor ->
        # there's a cycle
        raise CycleError, (answer, numpreds, successors)
    return answer

# get a header from a path to a local src.rpm; or False if no header
def get_header (path):
    debug ("Getting RPM header from %s" % path)
    # ignore signatures
    ts = rpm.TransactionSet ("", (rpm._RPMVSF_NOSIGNATURES))
    fd = os.open (path, os.O_RDONLY)
    try:
        h = ts.hdrFromFdno (fd)
    except:
        print "a whoopsie occurred."
    if not h:
        sys.stderr.write ("ERROR: %s doesn't look like a .src.rpm\n" % path)
        return False
    return h

 # return a list of BuildRequires: packages based on rpm header
def get_build_requires (header):
    buildreqs = header[rpm.RPMTAG_REQUIRENAME]
    # remove non-packagey things from buildreqs
    # currently removes everything containing (
    for pkg in buildreqs:
        if string.find (pkg, '(') >= 0:
            buildreqs.remove (pkg)
    return buildreqs

# find out name of spec file inside srpm
def get_spec_from_srpm (path):
# FIXME: rewrite using rpm module ?
    spec = commands.getoutput ('rpm -qlp %s 2> /dev/null | grep \.spec$' % path)
    debug ("get_spec_from_srpm: %s" % spec)
    return spec

# get all of the written rpms from the log file and return a tuple
# srpm, list of rpms
def get_rpms_from_log (log):
    rpms = []
    srpm = ''
    matchstr = re.compile ("src\.rpm$")
    output = commands.getoutput ('grep "Wrote: " %s | sort | uniq' % log)
    for line in output.split ("\n"):
        curr = string.replace (line, 'Wrote: ', '')
        if matchstr.search (curr):
            srpm = curr
        else:
            rpms.append (curr)
    return (srpm, rpms)

# print out debug info if wanted
# uses DEBUG global
def debug (string):
    if DEBUG:
        print "DEBUG: %s" % string

# return full path to directory based on the root (in config) and which sort
# of directory to get
def get_config_dir (config, which):
#FIXME: do error checking on key
    return config['dirs'][which + 's'] + '/' + config['root']

# return full path to directory holding bootstrap packages for this root
def get_packages_dir (config):
    return config['dirs']['packages'] + '/' + config['packages']['dir']

# make sure a dir exists
def ensure_dir (dir):
    if not os.path.exists (dir):
        try:
            os.makedirs (dir)
        except OSError:
            sys.stderr.write ("Could not create %s, make sure you have permissions to do so\n" % dir)
            sys.exit (1)

# get the list of sources.list lines based on the config
# based on sourceslist dict
def get_sources_list (config):
    sourceslist = []
    root = config['root']
    for platform in config['sourceslist'][root].keys ():
        for source in config['sourceslist'][root][platform]:
            sourceslist.append (config['aptsources'][platform][source])

    debug ("sources.list: " + string.join (sourceslist, "\n"))
    return sourceslist

# create sources.list file by putting the given list of lines in it
def create_sources_list (config, list):
    root = get_config_dir (config, 'root')
    debug ("Creating sources.list")
    # we created in the root and chroot mv it afterwards due to perms
    sources = open (root + '/tmp/sources.list', 'w')
    sources.write (string.join (list, "\n"))
    sources.close ()
    os.system ('%s %s mv /tmp/sources.list /etc/apt' % (config['chroot'], root))
    

# lock a given root; creates a lock file in the statedir under root
def lock (config):
    statedir = get_config_dir (config, 'state')
    ensure_dir (statedir)
    lockpath = statedir + '/lock'
    if os.path.exists (lockpath):
        if not config['force']:
            sys.stderr.write ('error: %s already locked !\n' % config['root'])
            return False
        else:
            print 'warning: overriding lock on root %s' % config['root']
    try:
        lockfile = open (lockpath, 'w')
    except:
        sys.stderr.write ('error: can''t create lock file for %s !\n' % config['root'])
        return False
    lockfile.close ()
    return True
        
# unlock a given root; removes lock file in the statedir under root
def unlock (config, notused=0):
    statedir = get_config_dir (config, 'state')
    lockpath = statedir + '/lock'
    if os.path.exists (lockpath):
        os.remove (lockpath)
        return True
    else:
        sys.stderr.write ('error: %s not locked !\n' % config['root'])
        return False
     
# return the state, or nothing if state isn't there
def get_state (config, state):
    statedir = get_config_dir (config, 'state')
    if os.path.exists (statedir + '/' + state):
        return statedir + '/' + state
    return

# check the given package list file
# remove all packages that aren't in this list file
def check_package_list (config, list):
    debug ("checking package list against snapshot")
    if config.has_key ('keep'):
        print "Not removing packages from root."
        return True
    root = get_config_dir (config, 'root')
    cmd = 'rpm --root %s -qa --qf %s | diff - %s > /dev/null 2>&1' % (root,
                                                                      qfmt,
                                                                      list)
    debug ("running " + cmd)
    if os.system (cmd) == 0:
        # no differences
        return True
    cmd = "rpm --root %s -qa --qf %s | grep -v -f %s - | tr '\n' ' '" % (root,
                                                                         qfmt,
                                                                         list)
    packages = commands.getoutput (cmd)
    # FIXME: how many ?
    sys.stdout.write ("Removing packages ...")
    if do_chroot (config, "%s -ev %s" % (chroot_rpm,  packages), True) != 0:
        sys.stderr.write ("Error removing packages\n")
        return False
    return True

# prepare a given root if not done yet; this ensures that a number of necessary
# files exist in the root
def setup_prep (config, args):
    if os.path.exists (get_config_dir (config, 'state') + '/prep'):
        return True
    print "Preparing root ..."
    root = get_config_dir (config, 'root')
    ensure_dir (root + '/etc/apt')
    ensure_dir (root + '/var/lib/rpm')
    #FIXME: os.chmod (root + '/var/lib/rpm', g+s)
    ensure_dir (root + '/dev')
    #FIXME: create /dev/null or install dev rpm
    ensure_dir (root + '/etc')
    open (root + '/etc/mtab', 'w')
    open (root + '/etc/fstab', 'w')

    debug ("Creating config files")
    for filename in config['files'].keys ():
        config_recreate (config, filename)

    ensure_dir (root + '/var/tmp')
    os.system ('rpm --root %s --initdb' % root)
    open (get_config_dir (config, 'state') + '/prep', 'w')
    return True

# recreate a given file listed in config['files']
def config_recreate (config, filename):
    root = get_config_dir (config, 'root')
    debug ("Recreating %s from config" % filename)
    if config['files'].has_key (filename):
        ensure_dir (os.path.dirname (root + filename))
        file = open (root + filename, 'w')
        file.write (config['files'][filename])
        file.close ()

# install a set of packages
# called by base and apt
def install (config, set):
    packagesdir = get_packages_dir (config)
    debug ("Installing package set %s" % set)
    statefile = get_config_dir (config, 'state') + '/' + set
    debug ("Checking statefile %s" % statefile)
    if os.path.exists (statefile):
        debug ("statefile exists")
        return True
    root = get_config_dir (config, 'root')
    debug ("Root dir %s" % root)
    ensure_dir (root + '/var/lib/rpm')
    # expand path for each package and install all of them at once
    # a roundabout way to prefix each rpm in the list with the path
    rpms = string.join (('', ) + config['packages'][set],
                        ' ' + packagesdir + '/')
    command = '%s --root %s -Uhv %s --nodeps --noorder --replacepkgs' % (config ['rpm'], root, rpms)
    debug ("Executing %s" % command)
    sys.stdout.write ("Installing %s packages ..." % set)
    do_progress (command)
    open (statefile, 'w')
    return True
    
# forcibly install a set of inconsistent base packages
def setup_base (config, args):
    return install (config, 'base')

# install packages needed for apt
def setup_apt (config, args):
    if not install (config, 'apt'):
        debug ("oops: couldn't install apt packages")
        return False
    return True

# force consistency
def setup_consistency (config, args):
    # trigger an apt-get update
    statefile = os.path.join (get_config_dir (config, 'state'), 'consistency')
    if os.path.exists (statefile):
        return True
    mount (config, args)
    rootdir = get_config_dir (config, 'root')
    srcs = get_sources_list (config)
    # first create a sources.list with only the first sources line
    # this ensures glibc doesn't get upgraded from underneath apt
    create_sources_list (config, (srcs[0], ))
    sys.stdout.write ('Updating apt from base source ...')
    do_chroot (config, "%s update" % chroot_aptget, True) and exit (config)
    sys.stdout.write ('Forcing consistency ...')
    do_chroot (config, "%s -f upgrade -y" % chroot_aptget, True) and exit (config)
    create_sources_list (config, srcs)
    sys.stdout.write ('Updating apt from all sources ...')
    do_chroot (config, "%s update" % chroot_aptget, True) and exit (config)
    sys.stdout.write ('Upgrading ...')
    do_chroot (config, "%s -f upgrade -y" % chroot_aptget, True) and exit (config)
    open (statefile, 'w')
    return True

# set up a 'root' for rpm building
def setup_build (config, args):
    statefile = get_config_dir (config, 'state') + '/build'
    if os.path.exists (statefile):
        # see if we need to revert to the given state
        return check_package_list (config, statefile)
    mount (config, args)
    root = get_config_dir (config, 'root')
    # install packages
    sys.stdout.write ('Installing rpm build packages ...')
    packages = "rpm-devel rpm-build make gcc tar gzip patch unzip diffutils"
    do_chroot (config, "%s install -y %s" % (chroot_aptget, packages), True)
    #FIXME: add mach user and group
    if do_chroot (config, "echo mach:!!:500:500::/usr/src/rpm:/bin/bash >> /etc/passwd") != 0:
        sys.stdout.write ("error: could not add mach user to /etc/passwd\n")
        exit (config)
    if do_chroot (config, "echo mach::500:mach >> /etc/group") != 0:
        sys.stdout.write ("error: could not add mach group to /etc/group\n")
        exit (config)
    do_chroot (config, "mkdir -p /usr/src/rpm")
    do_chroot (config, "chown -R mach:mach /usr/src/rpm")
    do_chroot (config, "su -c 'cp /etc/bashrc /usr/src/rpm/.bashrc' mach")
     # create dir structure and rpmmacros
    macros = open (root + '/tmp/macros', 'w')
    macros.write ("%_topdir /usr/src/rpm\n")
    macros.write ("%_rpmfilename %%{NAME}-%%{VERSION}-%%{RELEASE}.%%{ARCH}.rpm\n")
    macros.write ("%_unpackaged_files_terminate_build 1\n")
    macros.write ("%_missing_doc_files_terminate_build 1\n")
    macros.close ()
    if do_chroot (config, 'mv /tmp/macros /etc/rpm') != 0:
        sys.stdout.write ("error: could not create /etc/rpm\n")
        exit (config)
    for dir in ('RPMS', 'SRPMS', 'SOURCES', 'SPECS', 'BUILD'):
        if do_chroot (config, "su -c 'mkdir -p /usr/src/rpm/%s' mach" % dir) != 0:
            sys.stdout.write ("error: could not create /usr/src/rpm/%s\n" % dir)
            exit (config)

    # this ensures that locally built RPMS are already used for apt-get
    srcs = get_sources_list (config)
    srcs.insert (0, 'rpm-dir file:///usr/src rpm mach-local')
    create_sources_list (config, srcs) 
    for dir in ('RPMS', 'SRPMS'):
        if do_chroot (config, 'ln -s %s /usr/src/rpm/%s.mach-local' % (dir, dir)) != 0:
            sys.stdout.write ("error: could not create symlink /usr/src/rpm/%s.mach-local" % dir)
            exit (config)
    # make a snapshot
    sys.stdout.write ("Making snapshot ...")
    # FIXME: use _with_output for this
    do_chroot (config, "%s update" % chroot_aptget, True)
    command = "%s %s /bin/bash -c '%s -qa --qf %s'" % (config['chroot'], root, chroot_rpm, qfmt)
    file = open (statefile, 'w')
    for lines in os.popen (command).readlines ():
        file.write (lines)
    file.close ()
    umount (config, args)
    return True


# mount apt-archives and proc into chroot
def mount (config, args):
    # first umount for completeness
    umount (config, args)
    root = get_config_dir (config, 'root')
    statedir = get_config_dir (config, 'state')
    file = open (statedir + '/mount', "w+")
    os.system ('%s -t proc proc %s/proc' % (config['mount'], root))
    file.write ('%s/proc\n' % root)
    os.system ('%s -o bind %s %s/var/cache/apt/archives' % (config['mount'],
               config['dirs']['aptcache'], root))
    file.write ('%s/var/cache/apt/archives\n' % root)
    file.close ()
    
# umount all mounted paths
def umount (config, args):
    statedir = get_config_dir (config, 'state')
    mountfile = statedir + '/mount'
    if not os.path.exists (mountfile):
        return True
    os.system ('cat %s | xargs %s' % (mountfile, config['umount']))
    os.remove (mountfile)

# check if everything is in order to actually do stuff
def sanity_check (config):
    # check if partial dir exists
    partial = config['dirs']['aptcache'] + '/partial'
    ensure_dir (partial)
    return True

def check_packages (config):
    # if we already checked once, then we'll assume it's fine unless
    # a check was forced with -c or --check
    # FIXME: this doesn't survive mach clean, is that a problem ?
    statedir = get_config_dir (config, 'state')
    checkfile = os.path.join (statedir, 'check')
    if os.path.exists (checkfile) and not config['check']:
        return True

    # check if all packages are present
    packagesdir = get_packages_dir (config)
    print "Checking bootstrap packages ..."
    ensure_dir (packagesdir)
    for pkg in config['packages']['base'] + config['packages']['apt']:
        path = os.path.join (packagesdir, pkg)
        if not config['packages']['download'].has_key (pkg):
            url = config['packages']['download'][''] + '/' + pkg
        else:
            url = config['packages']['download'][pkg] + pkg
        if not os.path.exists (path):
            urlgrab (url, path)
        # verify that it's an rpm
        #ret = os.system ('rpm --checksig --nosignature %s > /dev/null 2>&1' % path)
        if os.system ('rpm --checksig --nosignature %s > /dev/null 2>&1' % path) != 0:
            os.remove (path)
            urlgrab (url, path)
            # retry
            if os.system ('rpm --checksig --nosignature %s > /dev/null 2>&1' % path) != 0:
                sys.stderr.write ('error: failed downloading %s\n' % url)
                return False
    ensure_dir (statedir)
    open (checkfile, 'w')
    return True
 
 
# implementation of commands

# build from a set of spec files
# do this by packaging them up as src.rpms and then passing them on to the
# rebuild section
def build (config, args):
    # check if we can build here yet
    if not get_state (config, 'build'):
        # trigger a cleanout of build root
        if not setup (config, ["build"]):
            return False
    if not lock (config):
        return False
    
    root = get_config_dir (config, 'root')
    ensure_dir (root)
    tmp = get_config_dir (config, 'tmp')
    srpms = [] # resulting set of srpms
    # check if the spec files exist and if we can parse the files necessary
    for specfile in args:
        if not os.path.exists (specfile):
            sys.stderr.write ('Spec %s does not exist !' % specfile)
            return False
        print "Building .src.rpm from %s" % os.path.basename (specfile)
        spec = Spec (specfile)
        (n, v, r) = spec.nvr ()
        downloads = spec.sources ().values () + spec.patches ().values ()
        # which paths will we check for already existing files ?
        # FIXME: add a temp stuff path somewhere instead of using current
        tmppath = "%s/%s-%s-%s" % (tmp, n, v, r)
        ensure_dir (tmppath)
        paths = [tmppath, '.', os.path.dirname (specfile)]
        # check if the files mentioned aren't already on-disk
        files = []
        for download in downloads:
            found = 0
            filename = os.path.basename (download)
            for path in paths:
                filepath = path + '/' + filename
                if os.path.exists (filepath):
                    print "Using %s" % filepath
                    files.append (filepath)
                    found = 1
            if not found:
                filepath = tmppath + "/" + filename
                try:
                    urlgrab (download, filepath)
                except:
                    sys.stderr.write ("Could not download %s !\n" % download)
                    return False
                files.append (filepath)
                print "Using %s" % filepath

        for file in files:
            shutil.copy2 (file, root + '/tmp')
            do_chroot (config, "mv /tmp/" + os.path.basename (file)
                                          + " /usr/src/rpm/SOURCES")
            shutil.copy2 (specfile, root + '/tmp')
            do_chroot (config, "mv /tmp/" + os.path.basename (specfile)
                                          + " /usr/src/rpm/SPECS")
        # we were stupid enough to think we couldn't build an src.rpm without
        # installing buildreqs.  of course, --nodeps takes care of that
        #buildreqs = spec.tags ("BuildRequires")
        #packages = []
        #for buildreq in buildreqs:
        #    package = string.split (buildreq, " ")[0]
        #    packages.append (package)
        #sys.stdout.write ("Installing BuildRequires ...")
        #do_chroot (config, "apt-get -y install %s" % string.join (packages, " "), True)

        sys.stdout.write ("Creating .src.rpm ...")
        if  do_chroot (config, "rpmbuild -bs --nodeps /usr/src/rpm/SPECS/"
                               + os.path.basename (specfile), True) != 0:
            sys.stderr.write ('error: could not build .src.rpm\n')
            return False
        (n, v, r) = spec.nvr ()
        srpmname = "%s-%s-%s.src.rpm" % (n, v, r)
        debug ("DEBUG: resulting srpm: %s" % srpmname)
        shutil.copy2 (root + '/usr/src/rpm/SRPMS/' + srpmname, tmppath)
        srpms.append (tmppath + '/' + srpmname)

    # ready to build them all
    print "Rebuilding generated .src.rpm's: \n- %s" % string.join (srpms, "\n- ")
    unlock (config)
    rebuild (config, srpms)
            
        


# forcibly check packages
def check (config, args):
    # force package check
    config['check'] = 1
    if check_packages (config):
        print "Everything ok."

# chroot into root
def chroot (config, args):
    rootdir = get_config_dir (config, 'root')
    print "Entering %s" % config['root']
    mount (config, args)
    os.system ("%s %s %s" % (config['chroot'], rootdir, string.join (args)))
    mount (config, args)
    
# clean up chroot
def clean (config, args):
    rootdir = get_config_dir (config, 'root')
    # force umount
    umount (config, args)
    # remove all state info
    statedir = get_config_dir (config, 'state')
    debug ("Removing statedir %s" % statedir)
    os.system ("rm -rf %s" % statedir)
    # FIXME: check if the dir isn't already clean yet
    if not os.path.exists (rootdir + '/bin/rm'):
        sys.stderr.write ('error: no base installed in %s !\n' % config['root'])
        # this is an ugly hack; we copy our rm and hope it works
        #ensure_dir (rootdir + '/bin')
        #os.path.copyfile ('/bin/rm', rootdir + '/bin/rm')
        return False
    # get a list of files and dirs in the root
    files = string.join (os.listdir (rootdir))
    sys.stdout.write ('Cleaning out root ...')
    do_chroot (config, 'rm -rfv %s' % files, True)
    os.rmdir (rootdir)

# rebuild a src rpm
def rebuild (config, args):
    root = get_config_dir (config, 'root')
    # check if we can build here yet
    #if not get_state (config, 'build'):
    # trigger a cleanout of build root
    if not setup (config, ["build"]):
        return False
    if not lock (config):
        return False

    config_recreate (config, '/usr/bin/apt-sigchecker')
    # get pkgs and collect info
    pkgs = {}
    for path in args:
	# resolve path to basename (without dirs)
        srpm = os.path.basename (path)
        newpath = root + '/tmp/' + srpm
        try:
            urlgrab (path, newpath)
        except IOError:
            sys.stderr.write ("Can't find %s !\n" % path)
            return False
        spec = get_spec_from_srpm (newpath)
        header = get_header (newpath)
        if not header:
            sys.stderr.write ('Cannot get header from %s\n' % newpath)
            continue
        buildreqs = get_build_requires (header)
        if buildreqs == False:
            unlock (config)
            return False
        name = header[rpm.RPMTAG_NAME]
        pkgs[name] = {}
        pkgs[name]['path'] = newpath
        pkgs[name]['buildreqs'] = buildreqs
        pkgs[name]['srpm'] = srpm
        pkgs[name]['header'] = header
        pkgs[name]['spec'] = spec
 
    # now figure out build order
    deps = [] # list of pkg, dep pairs
    for pkg in pkgs.keys ():
        print "Processing %s" % pkgs[pkg]['srpm']
        # figure out the build requirements
        for buildreq in pkgs[pkg]['buildreqs']:
            # we trash everything after the - if it's there in the hopes
            # that the result is the pkg providing this buildrequire
            # FIXME: use the rpm -q --specfile (spec) trick to do this
            # properly
            req = string.split (buildreq, "-")[0]
            debug ("Mangled %s to %s" % (buildreq, req))
            deps.append ((pkg, req))

    debug ("topological input: ")
    debug (deps)
    debug ("topological output: ")
    sorted = topological_sort (deps)
    sorted.reverse ()
    debug ("order %s" % sorted)
    # now scrub packages not up for build from order
    order = []
    for pkg in sorted:
        if pkg in pkgs.keys ():
            order.append (pkg)
    debug ("order %s" % order)

    # now make sure all packages given are up for build
    for pkg in pkgs.keys ():
        if pkg not in order:
            order.append (pkg)
    debug ("order %s" % order)

    # now build
    for name in order:
        srpm = pkgs[name]['srpm']
        print "Building %s" % srpm
        sys.stdout.write ('Installing BuildRequires ...')
        if do_chroot (config, '%s install -y %s' 
                              % (chroot_aptget, string.join (pkgs[name]['buildreqs'])),
                      True) != 0:
            sys.stderr.write ('Cannot build %s\n' % srpm)
            continue

        # get the name and create the place where to store results
        h = pkgs[name]['header']
        name = h[rpm.RPMTAG_NAME]
        version = h[rpm.RPMTAG_VERSION]
        release = h[rpm.RPMTAG_RELEASE]
        fullname = '%s-%s-%s' % (name, version, release)
        resultdir = get_config_dir (config, 'result') + '/' + fullname
        ensure_dir (resultdir)
        # rebuild binary rpm from the src rpm
        sys.stdout.write ("Rebuilding %s ..." % srpm)
        (status, output) = do_chroot_with_output (config,
            "su -c 'rpmbuild --rebuild --clean /tmp/%s 2>&1' mach" % srpm,
            True)
        if (output):
            open (resultdir + '/rpm.log', "wb"). write (output)
        if status != 0:
            sys.stderr.write ("ERROR: something went wrong building this one\n")
            sys.stderr.write ("ERROR: inspect rpm build log %s/rpm.log\n" % resultdir)
            unlock (config)
            return False
        # reinstall and repackage src rpm
        sys.stdout.write ("Repackaging %s ..." % srpm)
        #do_chroot (config, '%s -Uhv /tmp/%s > /dev/null 2>&1' % (chroot_rpm, srpm))
        do_chroot (config, "su -c 'rpm -Uhv /tmp/%s > /dev/null 2>&1' mach" % srpm)
        spec = pkgs[name]['spec']
        (status, output) = do_chroot_with_output (config,
         "su -c 'rpmbuild -bs --nodeps /usr/src/rpm/SPECS/%s 2>&1' mach" % spec,
            True)
        if output:
            open (resultdir + '/rpm.log', "ab"). write (output)
        if status != 0:
            sys.stderr.write ("ERROR: something went wrong repackaging SRPM\n")
            unlock (config)
            return False

        # analyze log file and move all of the rpms listed as Wrote:
        (srpm, rpms) = get_rpms_from_log (resultdir + '/rpm.log')
        # FIXME: install these RPMS based on a boolean ?
        # FIXME: error checks
        (status, output) = do_chroot_with_output (config, '%s -qp --qf "%%{name}=%%{epoch}:%%{version}-%%{release} " %s' % (chroot_rpm, string.join (rpms, " ")))
        # Need to handle packages without Epochs :/
        output = string.replace (output, '=(none):', '=');
        sys.stdout.write ("Installing built RPMS and dependencies ...")
        if do_chroot (config, '%s install -y %s' % (chroot_aptget, output), True) != 0:
            return False
        # FIXME: install the SRPM?
        print "Collecting results from %s" % srpm
        rpms.append (srpm)
        for file in rpms:
            # FIXME: a more python-like solution ?
            shutil.copy2 (root + '/' + file, resultdir)
            # for now, we do, for multiple builds
            do_chroot (config, 'rm ' + file)
        print "Build of %s succeeded." % fullname
        
    print "Build done."
    unlock (config)
    return True

# setup chroot
def setup (config, args):
    targets = ('prep', 'base', 'apt', 'consistency', 'build')
    if not args:
        args = ['build',] # default to build

    # see if something real given to setup
    if args[0] not in targets:
        sys.stderr.write ("error: don't know how to setup %s" % args[0])
        unlock (config)

    debug ("locking root")
    if not lock (config):
        return False
    debug ("checking packages")
    if not check_packages (config):
        exit (config)

        return False

    for target in targets:
        debug ("setting up target %s" % target)
        if not globals ()['setup_' + target] (config, args):
            sys.stderr.write ("error: couldn't setup target %s\n" % target)
            unlock (config)
            return False
        if args[0] == target:
            break

#    debug ("running prep")
#    setup_prep (config, args)
#    debug ("running base")
#    setup_base (config, args)
#    if (args[0] == base):
#        return True
#    debug ("running apt")
#    setup_apt (config, args)
#    debug ("running root")
#    setup_root (config, args)
#    debug ("running build")
#    setup_build (config, args)
#    debug ("unlocking root")
    if not unlock (config):
        return False
    return True

# give a status of each of the roots
def status (config, args):
    print "FIXME: write me" 
# main function
def main (config, args):
    global DEBUG # we might change it
    try:
        opts, args = getopt.getopt (args, 'r:hdfk',
                                    ['root=', 'help', 'debug', 'force', 'keep'])
    except getopt.error, exc:
        sys.stderr.write ('error: %s\n' % str (exc))
        sys.exit (1)

    # parse environment
    try:
        root = os.environ['MACH_ROOT']
    except:
        root = config['defaultroot']

    # parse config options
    for opt, arg in opts:
        if opt in ('-h', '--help'):
            print usage
            print help
            sys.exit (0)
        elif opt in ('-r', '--root'):
            root = arg
        elif opt in ('-d', '--debug'):
            DEBUG = 1
        elif opt in ('-f', '--force'):
            config['force'] = 1
        elif opt in ('-k', '--keep'):
            config['keep'] = 1

    # pull in root-specific configuration
    try:
        config['packages'] = packages[root]
    except KeyError:
        sys.stderr.write ('No definition for packages found for %s\n' % root)
        sys.exit (1)
    try:
        config['aptsources'] = aptsources
        config['sourceslist'] = sourceslist
    except KeyError:
        sys.stderr.write ('No sources information found for %s\n' % root)
        sys.exit (1)

    # debug output options
    debug ("root: %s" % root)

    # process options
    config['root'] = root

    # check if everything is ready to go
    sanity_check (config)

    # DEBUG DEBUG DEBUG:
    #get_sources_list (config)
    #rpms = get_rpms_from_log ('/home/thomas/prefix/var/tmp/mach/result/redhat-9-i386/drwright-0.16-0.fdr.1/rpm.log')
    #do_progress ("dmesg && sleep 1 && dmesg && sleep 1 && dmesg && true")
    #do_progress ("dmesg && sleep 1 && dmesg && sleep 1 && dmesg && false")
    #sys.exit (0)

    # run command
    if not args:
        print usage
        print help
        sys.exit (1)
    command = args[0]
    args = args[1:]
    debug ("running %s" % command)
    
    if command in allowed_commands:
        globals ()[command] (config, args)
    else:
        sys.stderr.write ("No such command '%s'\n" % command)
    #try:
    #globals()[command](config, args)
    #except:
    #    sys.stderr.write ('mach: unsupported command %s\n' % command)
    #    sys.exit (1)

# run main program

if __name__ == '__main__':
    # run command specified or go into interpreter mode
    if len (sys.argv) > 1:
        main (config, sys.argv[1:])
    else:
        print "starting mach interpreter ..."
        running = True;
        while running:
            sys.stdout.write ("> ")
            command = sys.stdin.readline ()
            main (string.split (command))

    
