#!/usr/bin/python
#
# mach - make a chroot
#
# script to set up a chroot using packages and optionally perform builds in it

import sys, os, getopt, string, commands, urllib, shutil, time, fcntl, re
import rpm # FIXME: find out what rpm version we need !

# make sure True and False constants exist

if not hasattr (__builtins__, 'True'):
    __builtins__.True = (1 == 1)
    __builtins__.False = (1 != 1)

# usage and help
usage = 'usage: mach [ -r root ] command [ options ... ]'
help = '''Make a chroot and do stuff in it.

Global options:
  -r, --root=ROOT		specify a root to work in
  -d, --debug			turn on debugging
  -f, --force			override root lock
  -k, --keep			do not revert buildroot to initial package list

Commands:
  chroot			chroot into root
  clean				totally cleans the root
  check				check if a root can be set up
  rebuild			rebuild a .src.rpm
  setup				sets up the root for a particular purpose
  status			show status of mach roots
  unlock			override root lock
'''

# read default configuration
config = {
  'statesdir': '@LOCALSTATEDIR@/state/mach',
  'rootsdir': '@LOCALSTATEDIR@/tmp/mach/roots',
  'resultsdir': '@LOCALSTATEDIR@/tmp/mach/result',
  'packagedir': '@LOCALSTATEDIR@/tmp/mach/packages',
  'tmpsdir': '@LOCALSTATEDIR@/tmp/mach/tmp',
  'aptcachedir': '@LOCALSTATEDIR@/cache/mach',

  'force': 0,
  'check': 0,
  'defaultroot': 'redhat-9-i386', # FIXME: based on configure's distro check

  'chroot': 'sudo /usr/sbin/chroot',
  'mount': 'sudo /bin/mount',
  'rpm': 'sudo /bin/rpm',
  'umount': 'sudo /bin/umount',

}
DEBUG = 0

# read system-wide configuration
file = '@SYSCONFDIR@/mach/conf'
execfile (file)

# read user configuration

# read package information
packages = {}
file = '@SYSCONFDIR@/mach/packages'
execfile (file)

# read apt information
aptsources = {}
sourceslist = {}
file = '@SYSCONFDIR@/mach/apt'
execfile (file)

# list of allowed commands
allowed_commands = ('build', 'check', 'chroot', 'clean', 'rebuild',
                    'setup', 'status', 'unlock')

### objects
class Spec:
    def __init__ (self, path):
        self.path = path
        self.content = []
        self.vars = {}
        self.content = open (self.path).readlines ()
        for which in ['name', 'version', 'release']:
            self.vars[which] = self.tag (which)

    def tag (self, which):
        "Get the given (unique) tag from the spec file as a string"
        if self.vars.has_key (which):
            return self.vars[which]

        matchstr = re.compile ("^" + which + r"\d*:\s*(.*)", re.I)
        for line in self.content:
            match = matchstr.search (line)
            if match:
                value = match.expand ("\\1")
                self.vars[which] = value
                return value
        return None

    def tags (self, which):
        "Get all given tags from the spec file as a list"
        result = []
        matchstr = re.compile ("^" + which + r"\d*:\s*(.*)", re.I)
        for line in self.content:
            match = matchstr.search (line)
            if match:
                value = match.expand ("\\1")
                result.append (value)
        return result

    # this is done quick and dirty, could be optimized more
    def expand (self, expression):
        "expand a line from a spec file using vars from the spec file"
        for variable in self.vars.keys ():
            expression = string.replace (expression, "%{" + variable + "}",
                                         self.vars[variable])
        #print "DEBUG: expanded to %s" % expression
        return expression

    def nvr (self):
        "return name, version, release triplet"
        return (self.vars['name'], self.vars['version'], self.vars['release'])
 

    # make this private
    def sourcespatches (self, which):
        result = {}
        matchstr = re.compile ("^(" + which + r"\d*):\s*(.*)")
        for line in self.content:
            match = matchstr.search (line)
            if match:
                tag = match.expand ("\\1")
                value = match.expand ("\\2")
                result[tag] = self.expand (value)
        return result
 
    def sources (self):
           # parse the spec file for all Source: files
           return self.sourcespatches ("Source")

    def patches (self):
           # parse the spec file for all Source: files
           return self.sourcespatches ("Patch")
 
### helper functions

# run a command, opening a pty and returning fd and pid
def pty_popen (cmd):
    pid, fd = os.forkpty ()
    if pid == 0:
        os.execl ('/bin/sh', 'sh', '-c', cmd)
    else:
        return os.fdopen (fd), pid

# run a command and give a progress spinner that regularly advances
# delta gives the number of secs between each spin iteration
# jump is the number of iterations before jumping one dot further
# return the return status of the app
def do_progress (cmd, delta = 0.1, jump = 60):
    progress = '/-\|'
    i = 0
    timestamp = time.time ()
    running = 1
    output = []
    (fdin, pid) = pty_popen (cmd)
    fcntl.fcntl (fdin, fcntl.F_SETFL, os.O_NONBLOCK) # don't block input
    sys.stdout.write ('|')
    while running:
        try:
            block = fdin.read ()
            output.append (block)
        except IOError:
            pass
        if time.time () > timestamp + delta:
            timestamp = time.time ()
            i = i + 1
            sys.stdout.write ('\b' + progress[i % len (progress)])
            if (i > jump):
                i = 0
                sys.stdout.write ('\b.-')
            sys.stdout.flush ()
        time.sleep (0.1)
        try:
            (dip, status) = os.waitpid (pid, os.WNOHANG)
        except OSError:
            running = 0
    if (status != 0):
        sys.stdout.write ('\b!\n')
        sys.stderr.write ('error:\n %s' % string.join (output))
    else: 
        sys.stdout.write ('\b.\n')
    return status

# execute the given command in the chroot; possibly with progress bar
# return return value of actual shell command
def do_chroot (config, command, progress = False):
    root = get_config_dir (config, 'root')
    cmd = '%s %s %s' % (config['chroot'], root, command)
    debug ("Executing %s" % cmd)
    if progress:
        return do_progress (cmd)
    else:
        return os.system (cmd)

# do a topological sort on the given list of pairs
# taken from a mail on the internet and adapted
# given the list of pairs of X needed for Y, return a suggested build list

def topological_sort (pairlist):
    numpreds = {}   # elt ->; # of predecessors
    successors = {} # elt -> list of successors
    for first, second in pairlist:
        # make sure every elt is a key in numpreds
        if not numpreds.has_key (first):
            numpreds[first] = 0
        if not numpreds.has_key (second):
            numpreds[second] = 0
                                                                                
        # since first < second, second gains a pred ...
        numpreds[second] = numpreds[second] + 1
                                                                                
        # ... and first gains a succ
        if successors.has_key (first):
            successors[first].append (second)
        else:
            successors[first] = [second]
                                                                                
    # suck up everything without a predecessor
    answer = filter (lambda x, numpreds=numpreds:
                         numpreds[x] == 0, numpreds.keys())
                                                                                
    # for everything in answer, knock down the pred count on
    # its successors; note that answer grows *in* the loop
    for x in answer:
        del numpreds[x]
        if successors.has_key (x):
            for y in successors[x]:
                numpreds[y] = numpreds[y] - 1
                if numpreds[y] == 0:
                    answer.append (y)
            # following "del" isn't needed; just makes
            # CycleError details easier to grasp
            del successors[x]
                                                                                
    if numpreds:
        # everything in numpreds has at least one successor ->
        # there's a cycle
        raise CycleError, (answer, numpreds, successors)
    return answer

# get a header from a path to a local src.rpm; or False if no header
def get_header (path):
    debug ("Getting RPM header from %s" % path)
    # ignore signatures
    ts = rpm.TransactionSet ("", (rpm._RPMVSF_NOSIGNATURES))
    fd = os.open (path, os.O_RDONLY)
    try:
        h = ts.hdrFromFdno (fd)
    except:
        print "a whoopsie occurred."
    if not h:
        sys.stderr.write ("ERROR: %s doesn't look like a .src.rpm\n" % path)
        return False
    return h

 # return a list of BuildRequires: packages based on rpm header
def get_build_requires (header):
    buildreqs = header[rpm.RPMTAG_REQUIRENAME]
    # remove non-packagey things from buildreqs
    # currently removes everything containing (
    for pkg in buildreqs:
        if string.find (pkg, '(') >= 0:
            buildreqs.remove (pkg)
    return buildreqs

# find out name of spec file inside srpm
def get_spec_from_srpm (path):
# FIXME: rewrite using rpm module ?
    spec = commands.getoutput ('rpm -qlp %s 2> /dev/null | grep \.spec$' % path)
    debug ("get_spec_from_srpm: %s" % spec)
    return spec

# get all of the written rpms from the log file and return as list
def get_rpms_from_log (log):
    output = commands.getoutput ('grep "Wrote: " %s | sort | uniq' % log)
    rpms = []
    for line in output.split ("\n"):
        rpms.append (string.replace (line, 'Wrote: ', ''),)
    return rpms

# print out debug info if wanted
# uses DEBUG global
def debug (string):
    if DEBUG:
        print "DEBUG: %s" % string

# return the dir given name of the root and name of the sort of dir
def get_config_dir (config, which):
#FIXME: do error checking on key
    return config[which + 'sdir'] + '/' + config['root']

# make sure a dir exists
def ensure_dir (dir):
    if not os.path.exists (dir):
        os.makedirs (dir)

# get the list of sources.list lines based on the config
# based on sourceslist dict
def get_sources_list (config):
    sourceslist = []
    root = config['root']
    for platform in config['sourceslist'][root].keys ():
        for source in config['sourceslist'][root][platform]:
            sourceslist.append (config['aptsources'][platform][source])

    debug ("sources.list: " + string.join (sourceslist, "\n"))
    return sourceslist

# create sources.list file by putting the given list of lines in it
def create_sources_list (config, list):
    root = get_config_dir (config, 'root')
    debug ("Creating sources.list")
    # we created in the root and chroot mv it afterwards due to perms
    sources = open (root + '/tmp/sources.list', 'w')
    sources.write (string.join (list, "\n"))
    sources.close ()
    os.system ('%s %s mv /tmp/sources.list /etc/apt' % (config['chroot'], root))
    

# lock a given root; creates a lock file in the statedir under root
def lock (config, args):
    statedir = get_config_dir (config, 'state')
    ensure_dir (statedir)
    lockpath = statedir + '/lock'
    if os.path.exists (lockpath):
        if not config['force']:
            sys.stderr.write ('error: %s already locked !\n' % config['root'])
            return False
        else:
            print 'warning: overriding lock on root %s' % config['root']
    try:
        lockfile = open (lockpath, 'w')
    except:
        sys.stderr.write ('error: can''t create lock file for %s !\n' % config['root'])
        return False
    lockfile.close ()
    return True
        
# unlock a given root; removes lock file in the statedir under root
def unlock (config, args):
    statedir = get_config_dir (config, 'state')
    lockpath = statedir + '/lock'
    if os.path.exists (lockpath):
        os.remove (lockpath)
        return True
    else:
        sys.stderr.write ('error: %s not locked !\n' % config['root'])
        return False
     
# return the state, or nothing if state isn't there
def get_state (config, state):
    statedir = get_config_dir (config, 'state')
    if os.path.exists (statedir + '/' + state):
        return statedir + '/' + state
    return

# check the given package list and remove all packages that aren't in this list
def check_package_list (config, list):
    debug ("checking package list against snapshot")
    if config.has_key ('keep'):
        print "Not removing packages from root."
        return True
    root = get_config_dir (config, 'root')
    cmd = 'rpm --root %s -qa | diff - %s > /dev/null 2>&1' % (root, list)
    debug ("running " + cmd)
    if os.system (cmd) == 0:
        # no differences
        return True
    cmd = "rpm --root %s -qa | grep -v -f %s - | tr '\n' ' '" % (root, list)
    packages = commands.getoutput (cmd)
    # FIXME: how many ?
    sys.stdout.write ("Removing packages ...")
    if do_chroot (config, "rpm -ev " + packages, True) != 0:
        sys.stderr.write ("Error removing packages\n")
        return False
    return True

# prepare a given root if not done yet; this ensures that a number of necessary
# files exist in the root
def setup_prep (config, args):
    if os.path.exists (get_config_dir (config, 'state') + '/prep'):
        return True
    print "Preparing root ..."
    root = get_config_dir (config, 'root')
    ensure_dir (root + '/etc/apt')
    ensure_dir (root + '/var/lib/rpm')
    #FIXME: os.chmod (root + '/var/lib/rpm', g+s)
    ensure_dir (root + '/dev')
    #FIXME: create /dev/null or install dev rpm
    ensure_dir (root + '/etc')
    open (root + '/etc/mtab', 'w')
    open (root + '/etc/fstab', 'w')

    

    for filename in config['files'].keys ():
        file = open (root + filename, 'w')
        file.write (config['files'][filename])
        file.close ()

    ensure_dir (root + '/var/tmp')
    os.system ('rpm --root %s --initdb' % root)
    open (get_config_dir (config, 'state') + '/prep', 'w')
    return True

# install a set of packages
# called by base and apt
def install (config, set):
    debug ("Installing package set %s" % set)
    statefile = get_config_dir (config, 'state') + '/' + set
    debug ("Checking statefile %s" % statefile)
    if os.path.exists (statefile):
        debug ("statefile exists")
        return True
    root = get_config_dir (config, 'root')
    debug ("Root dir %s" % root)
    ensure_dir (root + '/var/lib/rpm')
    # expand path for each package and install all of them at once
    # a roundabout way to prefix each rpm in the list with the path
    rpms = string.join (('', ) + config['packages'][set], ' ' 
                               + config['packagedir'] + '/')
    command = '%s --root %s -Uhv %s --nodeps --noorder --replacepkgs' % (config ['rpm'], root, rpms)
    debug ("Executing %s" % command)
    sys.stdout.write ("Installing %s packages ..." % set)
    do_progress (command)
    open (statefile, 'w')
    return True

    
# forcibly install a set of inconsistent base packages
def setup_base (config, args):
    return install (config, 'base')

# install packages needed for apt and force an apt-update
def setup_apt (config, args):
    if not install (config, 'apt'):
        debug ("oops: couldn't install apt packages")
        return False
    # trigger an apt-get update
    mount (config, args)
    rootdir = get_config_dir (config, 'root')
    create_sources_list (config, get_sources_list (config))
    sys.stdout.write ('Updating apt ...')
    do_progress ('%s %s apt-get update' % (config['chroot'], rootdir))
    sys.stdout.write ('Forcing consistency ...')
    do_progress ('%s %s apt-get -f upgrade -y' % (config['chroot'], rootdir))
    umount (config, args)
    return True

# set up a 'root' for rpm building
def setup_build (config, args):
    statefile = get_config_dir (config, 'state') + '/build'
    if os.path.exists (statefile):
        # see if we need to revert to the given state
        return check_package_list (config, statefile)
    mount (config, args)
    root = get_config_dir (config, 'root')
    # install packages
    sys.stdout.write ('Installing rpm build packages ...')
    do_chroot (config, 'apt-get install -y rpm-devel rpm-build make gcc tar gzip patch unzip diffutils', True)
    # create dir structure and rpmmacros
    macros = open (root + '/tmp/macros', 'w')
    macros.write ('%_topdir /usr/src/rpm')
    macros.close ()
    os.system ('%s %s mv /tmp/macros /etc/rpm' % (config['chroot'], root))
    for dir in ('RPMS', 'SRPMS', 'SOURCES', 'SPECS', 'BUILD'):
        os.system ('%s %s mkdir -p /usr/src/rpm/%s' % (config['chroot'], root, dir))
    #FIXME: add mach user and group
    do_chroot (config,
               "echo 'mach:!!:500:500::/usr/src/rpm:/bin/bash' >> /etc/passwd")
    do_chroot (config,
               "echo 'mach::500:mach' >> /etc/group")
    # make a snapshot
    command = '%s %s rpm -qa' % (config['chroot'], root)
    file = open (statefile, 'w')
    for lines in os.popen (command).readlines ():
        file.write (lines)
    file.close ()
    umount (config, args)
    return True


# mount apt-archives and proc into chroot
def mount (config, args):
    # first umount for completeness
    umount (config, args)
    root = get_config_dir (config, 'root')
    statedir = get_config_dir (config, 'state')
    file = open (statedir + '/mount', "w+")
    os.system ('%s -t proc proc %s/proc' % (config['mount'], root))
    file.write ('%s/proc\n' % root)
    os.system ('%s -o bind %s %s/var/cache/apt/archives' % (config['mount'],
               config['aptcachedir'], root))
    file.write ('%s/var/cache/apt/archives\n' % root)
    file.close ()
    
# umount all mounted paths
def umount (config, args):
    statedir = get_config_dir (config, 'state')
    mountfile = statedir + '/mount'
    if not os.path.exists (mountfile):
        return True
    os.system ('cat %s | xargs %s' % (mountfile, config['umount']))
    os.remove (mountfile)

# check if everything is in order to actually do stuff
def sanity_check (config):
    # check if partial dir exists
    partial = config['aptcachedir'] + '/partial'
    if not os.path.exists (partial):
        os.makedirs (partial) 
    return True

def check_packages (config):
    # if we already checked once, then we'll assume it's fine unless
    # a check was forced with -c or --check
    # FIXME: this doesn't survive mach clean, is that a problem ?
    checkfile = get_config_dir (config, 'state') + '/check'
    if os.path.exists (checkfile) and not config['check']:
        return True

    # check if all packages are present
    print "Checking bootstrap packages ..."
    ensure_dir (config['packagedir'])
    for pkg in config['packages']['base'] + config['packages']['apt']:
        path = config['packagedir'] + '/' + pkg
        if not config['packages']['download'].has_key (pkg):
            url = config['packages']['download'][''] + '/' + pkg
        else:
            url = config['packages']['download'][pkg] + pkg
        if not os.path.exists (path):
            # get it
            print "downloading %s" % url
            urllib.urlretrieve (url, path)
        # verify that it's an rpm
        #ret = os.system ('rpm --checksig --nosignature %s > /dev/null 2>&1' % path)
        if os.system ('rpm --checksig --nosignature %s > /dev/null 2>&1' % path) != 0:
            os.remove (path)
            print "downloading %s" % url
            urllib.urlretrieve (url, path)
            # retry
            if os.system ('rpm --checksig --nosignature %s > /dev/null 2>&1' % path) != 0:
                sys.stderr.write ('error: failed downloading %s\n' % url)
                return False
    open (checkfile, 'w')
    return True
 
 
# implementation of commands

# build from a set of spec files
# do this by packaging them up as src.rpms and then passing them on to the
# rebuild section
def build (config, args):
    # check if we can build here yet
    #if not get_state (config, 'build'):
    # trigger a cleanout of build root
    #if not setup (config, ["build"]):
    #    return False
    if not lock (config, args):
        return False
    
    root = get_config_dir (config, 'root')
    tmp = get_config_dir (config, 'tmp')
    srpms = [] # resulting set of srpms
    # check if the spec files exist and if we can parse the files necessary
    for specfile in args:
        if not os.path.exists (specfile):
            sys.stderr.write ('Spec %s does not exist !' % specfile)
            return False
        print "Building .src.rpm from %s" % os.path.basename (specfile)
        spec = Spec (specfile)
        (n, v, r) = spec.nvr ()
        downloads = spec.sources ().values () + spec.patches ().values ()
        # which paths will we check for already existing files ?
        # FIXME: add a temp stuff path somewhere instead of using current
        tmppath = "%s/%s-%s-%s" % (tmp, n, v, r)
        ensure_dir (tmppath)
        paths = ['tmppath', '.', os.path.dirname (specfile)]
        # check if the files mentioned aren't already on-disk
        files = []
        for download in downloads:
            found = 0
            filename = os.path.basename (download)
            for path in paths:
                filepath = path + '/' + filename
                if os.path.exists (filepath):
                    print "Using %s" % filepath
                    files.append (filepath)
                    found = 1
            if not found:
                print "Downloading %s ..." % download
                filepath = tmppath + "/" + filename
                if not urllib.urlretrieve (download, filepath):
                    sys.stderr.write ("Could not download %s !\n" % download)
                    return False
                files.append (filepath)
                print "Using %s" % filepath

        for file in files:
            shutil.copy (file, root + '/tmp')
            do_chroot (config, "mv /tmp/" + os.path.basename (file)
                                          + " /usr/src/rpm/SOURCES")
            shutil.copy (specfile, root + '/tmp')
            do_chroot (config, "mv /tmp/" + os.path.basename (specfile)
                                          + " /usr/src/rpm/SPECS")
        # we were stupid enough to think we couldn't build an src.rpm without
        # installing buildreqs.  of course, --nodeps takes care of that
        #buildreqs = spec.tags ("BuildRequires")
        #packages = []
        #for buildreq in buildreqs:
        #    package = string.split (buildreq, " ")[0]
        #    packages.append (package)
        #sys.stdout.write ("Installing BuildRequires ...")
        #do_chroot (config, "apt-get -y install %s" % string.join (packages, " "), True)

        do_chroot (config, "rpmbuild -bs --nodeps /usr/src/rpm/SPECS/"
                           + os.path.basename (specfile) + "> /dev/null 2>&1")
        (n, v, r) = spec.nvr ()
        srpmname = "%s-%s-%s.src.rpm" % (n, v, r)
        debug ("DEBUG: resulting srpm: %s" % srpmname)
        shutil.copy (root + '/usr/src/rpm/SRPMS/' + srpmname, tmppath)
        srpms.append (srpmname)

    # ready to build them all
    print "Rebuilding generated .src.rpm's: %s " % string.join (srpms)
    rebuild (config, srpms)
            
        


# forcibly check packages
def check (config, args):
    # force package check
    config['check'] = 1
    if check_packages (config):
        print "Everything ok."

# chroot into root
def chroot (config, args):
    rootdir = get_config_dir (config, 'root')
    print "Entering %s" % config['root']
    os.system ("%s %s" % (config['chroot'], rootdir))
    
# clean up chroot
def clean (config, args):
    rootdir = get_config_dir (config, 'root')
    # force umount
    umount (config, args)
    # FIXME: check if the dir isn't already clean yet
    if not os.path.exists (rootdir + '/bin/rm'):
        sys.stderr.write ('error: no base installed in %s !\n' % config['root'])
        # this is an ugly hack; we copy our rm and hope it works
        #ensure_dir (rootdir + '/bin')
        #os.path.copyfile ('/bin/rm', rootdir + '/bin/rm')
        return False
    # remove all state info
    statedir = get_config_dir (config, 'state')
    os.system ("rm -rf %s" % statedir)
    # get a list of files and dirs in the root
    files = string.join (os.listdir (rootdir))
    sys.stdout.write ('Cleaning out root ...')
    do_chroot (config, 'rm -rf %s' % files, True)
    os.rmdir (rootdir)

# rebuild a src rpm
def rebuild (config, args):
    root = get_config_dir (config, 'root')
    # check if we can build here yet
    #if not get_state (config, 'build'):
    # trigger a cleanout of build root
    if not setup (config, ["build"]):
        return False
    if not lock (config, args):
        return False

    # get pkgs and collect info
    pkgs = {}
    for path in args:
	# resolve path to basename (without dirs)
        srpm = os.path.basename (path)
        newpath = root + '/tmp/' + srpm
        print "Getting %s" % srpm
        urllib.urlretrieve (path, newpath)
        spec = get_spec_from_srpm (newpath)
        header = get_header (newpath)
        if not header:
            sys.stderr.write ('Cannot build %s\n' % srpm)
            continue
        buildreqs = get_build_requires (header)
        if buildreqs == False:
            unlock (config, args)
            return False
        name = header[rpm.RPMTAG_NAME]
        pkgs[name] = {}
        pkgs[name]['path'] = newpath
        pkgs[name]['buildreqs'] = buildreqs
        pkgs[name]['srpm'] = srpm
        pkgs[name]['header'] = header
        pkgs[name]['spec'] = spec
 
    # now figure out build order
    deps = [] # list of pkg, dep pairs
    for pkg in pkgs.keys ():
        print "Processing %s" % pkgs[pkg]['srpm']
        # figure out the build requirements
        for buildreq in pkgs[pkg]['buildreqs']:
            # FIXME: this is a hack
            # we trash everything after the - if it's there in the hopes
            # that the result is the pkg providing this buildrequire
            req = string.split (buildreq, "-")[0]
            debug ("Mangled %s to %s" % (buildreq, req))
            deps.append ((pkg, req))

    debug ("DEBUG: topological input: ")
    debug (deps)
    debug ("DEBUG: topological output: ")
    sorted = topological_sort (deps)
    sorted.reverse ()
    debug ("DEBUG: order %s" % sorted)
    # now scrub packages not up for build from order
    order = []
    for pkg in sorted:
        if pkg in pkgs.keys ():
            order.append (pkg)
    debug ("order %s" % order)

    for name in order:
        srpm = pkgs[name]['srpm']
        print "Building %s" % srpm
        sys.stdout.write ('Installing BuildRequires ...')
        if do_chroot (config, 'apt-get install -y %s' 
                              % string.join (pkgs[name]['buildreqs']), True) != 0:
            sys.stderr.write ('Cannot build %s\n' % srpm)
            continue

        # get the name and create the place where to store results
        h = pkgs[name]['header']
        name = h[rpm.RPMTAG_NAME]
        version = h[rpm.RPMTAG_VERSION]
        release = h[rpm.RPMTAG_RELEASE]
        fullname = '%s-%s-%s' % (name, version, release)
        resultdir = get_config_dir (config, 'result') + '/' + fullname
        ensure_dir (resultdir)
        # rebuild binary rpm from the src rpm
        sys.stdout.write ("Rebuilding %s ..." % srpm)
        if do_chroot (config, 'rpmbuild --rebuild /tmp/%s 2>&1 | tee %s'
                              % (srpm, resultdir + '/rpm.log'), True) != 0:
            sys.stderr.write ("ERROR: something went wrong building this one\n")
            sys.stderr.write ("ERROR: last 10 lines of build log:\n")
            command = 'tail -n 10 %s/rpm.log' % resultdir
            sys.stderr.write (commands.getoutput (command))
            unlock (config, args)
            return False
        # reinstall and repackage src rpm
        sys.stdout.write ("Repackaging %s ..." % srpm)
        do_chroot (config, 'rpm -Uhv /tmp/%s > /dev/null 2>&1' % srpm)
        spec = pkgs[name]['spec']
        if do_chroot (config, 'rpmbuild -bs /usr/src/rpm/SPECS/%s >> %s 2>&1'
                              % (spec, resultdir + '/rpm.log'), True):
            print "ERROR: something went wrong repackaging SRPM"

        # analyze log file and move all of the rpms listed as Wrote:
        rpms = get_rpms_from_log (resultdir + '/rpm.log')
        sys.stdout.write ("Installing built RPMS ...")
        do_chroot (config, 'rpm -Uhv %s' % string.join (rpms, " "), True)
        # FIXME: install these RPMS based on a boolean ?
        print "Collecting results from %s" % srpm
        for file in rpms:
            # FIXME: a more python-like solution ?
            shutil.copy (root + '/' + file, resultdir)
            # for now, we do, for multiple builds
            do_chroot (config, 'rm ' + file)
        print "Build of %s succeeded." % fullname
        
    print "Build done."
    unlock (config, args)
    return True

# setup chroot
def setup (config, args):
    targets = ('prep', 'base', 'apt', 'build')
    if not args:
        args = ['build',] # default to build

    # see if something real given to setup
    if args[0] not in targets:
        sys.stderr.write ("error: don't know how to setup %s" % args[0])
        unlock (config, args)

    debug ("locking root")
    if not lock (config, args):
        return False
    debug ("checking packages")
    if not check_packages (config):
        unlock (config, args)
        sys.exit (1)

        return False

    for target in targets:
        debug ("setting up target %s" % target)
        if not globals ()['setup_' + target] (config, args):
            sys.stderr.write ("error: couldn't setup target %s\n" % target)
            unlock (config, args)
            return False
        if args[0] == target:
            break

#    debug ("running prep")
#    setup_prep (config, args)
#    debug ("running base")
#    setup_base (config, args)
#    if (args[0] == base):
#        return True
#    debug ("running apt")
#    setup_apt (config, args)
#    debug ("running root")
#    setup_root (config, args)
#    debug ("running build")
#    setup_build (config, args)
#    debug ("unlocking root")
    if not unlock (config, args):
        return False
    return True

# give a status of each of the roots
def status (config, args):
    print "FIXME: write me" 

# main function
def main (config, args):
    global DEBUG # we might change it
    try:
        opts, args = getopt.getopt (args, 'r:hdfk',
                                    ['root=', 'help', 'debug', 'force', 'keep'])
    except getopt.error, exc:
        sys.stderr.write ('error: %s\n' % str (exc))
        sys.exit (1)

    # parse environment
    try:
        root = os.environ['MACH_ROOT']
    except:
        root = config['defaultroot']

    # parse config options
    for opt, arg in opts:
        if opt in ('-h', '--help'):
            print usage
            print help
            sys.exit (0)
        elif opt in ('-r', '--root'):
            root = arg
        elif opt in ('-d', '--debug'):
            DEBUG = 1
        elif opt in ('-f', '--force'):
            config['force'] = 1
        elif opt in ('-k', '--keep'):
            config['keep'] = 1

    # pull in root-specific configuration
    try:
        config['packages'] = packages[root]
    except KeyError:
        sys.stderr.write ('No definition for packages found for %s\n' % root)
        sys.exit (1)
    try:
        config['aptsources'] = aptsources
        config['sourceslist'] = sourceslist
    except KeyError:
        sys.stderr.write ('No sources information found for %s\n' % root)
        sys.exit (1)

    # debug output options
    debug ("root: %s" % root)

    # process options
    config['root'] = root

    # check if everything is ready to go
    sanity_check (config)

    # DEBUG DEBUG DEBUG:
    #get_sources_list (config)
    #rpms = get_rpms_from_log ('/home/thomas/prefix/var/tmp/mach/result/redhat-9-i386/drwright-0.16-0.fdr.1/rpm.log')

    # run command
    if not args:
        print usage
        print help
        sys.exit (1)
    command = args[0]
    args = args[1:]
    debug ("running %s" % command)
    
    if command in allowed_commands:
        globals ()[command] (config, args)
    else:
        sys.stderr.write ("No command '%s'\n" % command)
    #try:
    #globals()[command](config, args)
    #except:
    #    sys.stderr.write ('mach: unsupported command %s\n' % command)
    #    sys.exit (1)

# run main program

if __name__ == '__main__':
    # run command specified or go into interpreter mode
    if len (sys.argv) > 1:
        main (config, sys.argv[1:])
    else:
        print "starting mach interpreter ..."
        running = True;
        while running:
            sys.stdout.write ("> ")
            command = sys.stdin.readline ()
            main (string.split (command))

    
